package server

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gorilla/websocket"
	"gorm.io/gorm"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	"k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	policyv1 "k8s.io/api/policy/v1"
	storagev1 "k8s.io/api/storage/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	k8syaml "k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/remotecommand"
	"k8s.io/metrics/pkg/apis/metrics/v1beta1"
	"sigs.k8s.io/yaml"

	"github.com/ydcloud-dy/opshub/plugins/kubernetes/service"
)

// ResourceHandler Kubernetesèµ„æºå¤„ç†å™¨
type ResourceHandler struct {
	clusterService *service.ClusterService
	db             *gorm.DB
}

// NewResourceHandler åˆ›å»ºèµ„æºå¤„ç†å™¨
func NewResourceHandler(clusterService *service.ClusterService, db *gorm.DB) *ResourceHandler {
	return &ResourceHandler{
		clusterService: clusterService,
		db:             db,
	}
}

// JwtClaims JWTå£°æ˜ç»“æ„
type JwtClaims struct {
	UserID   uint   `json:"user_id"`
	Username string `json:"username"`
	jwt.RegisteredClaims
}

// verifyTokenAndGetUserID éªŒè¯JWT tokenå¹¶è¿”å›ç”¨æˆ·ID
func (h *ResourceHandler) verifyTokenAndGetUserID(tokenString string) (uint, error) {
	// ä»ç¯å¢ƒå˜é‡è·å–JWTå¯†é’¥
	secretKey := os.Getenv("OPSHUB_SERVER_JWT_SECRET")
	if secretKey == "" {
		secretKey = "your-secret-key-change-in-production" // é»˜è®¤å€¼
	}

	token, err := jwt.ParseWithClaims(tokenString, &JwtClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(secretKey), nil
	})

	if err != nil {
		return 0, fmt.Errorf("tokenè§£æå¤±è´¥: %w", err)
	}

	if claims, ok := token.Claims.(*JwtClaims); ok && token.Valid {
		return claims.UserID, nil
	}

	return 0, errors.New("invalid token")
}

// handleGetClientsetError å¤„ç† GetClientsetForUser çš„é”™è¯¯
// è¿”å› true è¡¨ç¤ºé”™è¯¯å·²å¤„ç†ï¼ˆå‘é€äº†å“åº”ï¼‰ï¼Œè°ƒç”¨è€…åº”è¯¥ return
// è¿”å› false è¡¨ç¤ºä¸æ˜¯å‡­æ®é”™è¯¯ï¼Œéœ€è¦ç»§ç»­å¤„ç†
func (h *ResourceHandler) handleGetClientsetError(c *gin.Context, err error) bool {
	if err == nil {
		return false
	}
	// æ‰“å°é”™è¯¯ä¿¡æ¯ç”¨äºè°ƒè¯•
	fmt.Printf("ğŸ” [handleGetClientsetError] é”™è¯¯ä¿¡æ¯: %s\n", err.Error())

	// æ£€æŸ¥æ˜¯å¦æ˜¯"ç”¨æˆ·å°šæœªç”³è¯·å‡­æ®"é”™è¯¯
	if strings.Contains(err.Error(), "å°šæœªç”³è¯·") || strings.Contains(err.Error(), "å‡­æ®") {
		fmt.Printf("âŒ [handleGetClientsetError] è¿”å› 403\n")
		c.JSON(http.StatusForbidden, gin.H{
			"code":    403,
			"message": "æ‚¨å°šæœªç”³è¯·è¯¥é›†ç¾¤çš„è®¿é—®å‡­æ®ï¼Œè¯·åœ¨é›†ç¾¤ç®¡ç†é¡µé¢ç”³è¯· kubeconfig åå†è®¿é—®",
		})
		return true
	}
	fmt.Printf("âš ï¸ [handleGetClientsetError] ä¸æ˜¯å‡­æ®é”™è¯¯ï¼Œè¿”å› false\n")
	return false
}

// NodeInfo èŠ‚ç‚¹ä¿¡æ¯
type NodeInfo struct {
	Name             string            `json:"name"`
	Status           string            `json:"status"`
	Roles            string            `json:"roles"`
	Age              string            `json:"age"`
	Version          string            `json:"version"`
	InternalIP       string            `json:"internalIP"`
	ExternalIP       string            `json:"externalIP,omitempty"`
	OSImage          string            `json:"osImage"`
	KernelVersion    string            `json:"kernelVersion"`
	ContainerRuntime string            `json:"containerRuntime"`
	Labels           map[string]string `json:"labels"`
	Annotations      map[string]string `json:"annotations"`
	// æ–°å¢å­—æ®µ
	CPUCapacity    string          `json:"cpuCapacity"`    // CPUå®¹é‡
	MemoryCapacity string          `json:"memoryCapacity"` // å†…å­˜å®¹é‡
	CPUUsed        int64           `json:"cpuUsed"`        // CPUä½¿ç”¨é‡ï¼ˆæ¯«æ ¸ï¼‰
	MemoryUsed     int64           `json:"memoryUsed"`     // å†…å­˜ä½¿ç”¨é‡ï¼ˆå­—èŠ‚ï¼‰
	PodCount       int             `json:"podCount"`       // Podæ•°é‡
	PodCapacity    int             `json:"podCapacity"`    // Podå®¹é‡
	Schedulable    bool            `json:"schedulable"`    // æ˜¯å¦å¯è°ƒåº¦
	TaintCount     int             `json:"taintCount"`     // æ±¡ç‚¹æ•°é‡
	Taints         []TaintInfo     `json:"taints"`         // æ±¡ç‚¹è¯¦æƒ…
	PodCIDR        string          `json:"podCIDR"`        // Pod CIDR
	ProviderID     string          `json:"providerID"`     // Provider ID
	Conditions     []NodeCondition `json:"conditions"`     // èŠ‚ç‚¹æ¡ä»¶
}

// TaintInfo æ±¡ç‚¹ä¿¡æ¯
type TaintInfo struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

// NodeCondition èŠ‚ç‚¹æ¡ä»¶
type NodeCondition struct {
	Type               string `json:"type"`
	Status             string `json:"status"`
	LastHeartbeatTime  string `json:"lastHeartbeatTime"`
	LastTransitionTime string `json:"lastTransitionTime"`
	Reason             string `json:"reason"`
	Message            string `json:"message"`
}

// PodInfo Podä¿¡æ¯
type PodInfo struct {
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Ready     string            `json:"ready"`
	Status    string            `json:"status"`
	Restarts  int32             `json:"restarts"`
	Age       string            `json:"age"`
	IP        string            `json:"ip"`
	Node      string            `json:"node"`
	Labels    map[string]string `json:"labels"`
}

// NamespaceInfo å‘½åç©ºé—´ä¿¡æ¯
type NamespaceInfo struct {
	Name   string            `json:"name"`
	Status string            `json:"status"`
	Age    string            `json:"age"`
	Labels map[string]string `json:"labels"`
}

// DeploymentInfo Deploymentä¿¡æ¯
type DeploymentInfo struct {
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Ready     string            `json:"ready"`
	UpToDate  int32             `json:"upToDate"`
	Available int32             `json:"available"`
	Age       string            `json:"age"`
	Replicas  int32             `json:"replicas"`
	Selector  map[string]string `json:"selector"`
	Labels    map[string]string `json:"labels"`
}

// DaemonSetInfo DaemonSetä¿¡æ¯
type DaemonSetInfo struct {
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Ready     string            `json:"ready"`
	Age       string            `json:"age"`
	Labels    map[string]string `json:"labels"`
}

// StatefulSetInfo StatefulSetä¿¡æ¯
type StatefulSetInfo struct {
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Ready     string            `json:"ready"`
	Age       string            `json:"age"`
	Labels    map[string]string `json:"labels"`
}

// JobInfo Jobä¿¡æ¯
type JobInfo struct {
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Ready     string            `json:"ready"`
	Age       string            `json:"age"`
	Labels    map[string]string `json:"labels"`
}

// ClusterStats é›†ç¾¤ç»Ÿè®¡ä¿¡æ¯
type ClusterStats struct {
	NodeCount         int     `json:"nodeCount"`
	WorkloadCount     int     `json:"workloadCount"` // Deployment + DaemonSet + StatefulSet + Job
	PodCount          int     `json:"podCount"`
	CPUUsage          float64 `json:"cpuUsage"`          // CPUä½¿ç”¨ç‡ç™¾åˆ†æ¯”
	MemoryUsage       float64 `json:"memoryUsage"`       // å†…å­˜ä½¿ç”¨ç‡ç™¾åˆ†æ¯”
	CPUCapacity       float64 `json:"cpuCapacity"`       // CPUæ€»æ ¸æ•°
	MemoryCapacity    float64 `json:"memoryCapacity"`    // å†…å­˜æ€»å®¹é‡(å­—èŠ‚)
	CPUAllocatable    float64 `json:"cpuAllocatable"`    // CPUå¯åˆ†é…é‡
	MemoryAllocatable float64 `json:"memoryAllocatable"` // å†…å­˜å¯åˆ†é…é‡(å­—èŠ‚)
	CPUUsed           float64 `json:"cpuUsed"`           // CPUå·²ä½¿ç”¨é‡
	MemoryUsed        float64 `json:"memoryUsed"`        // å†…å­˜å·²ä½¿ç”¨é‡(å­—èŠ‚)
}

// ClusterNetworkInfo é›†ç¾¤ç½‘ç»œä¿¡æ¯
type ClusterNetworkInfo struct {
	ServiceCIDR      string `json:"serviceCIDR"`      // Service CIDR
	PodCIDR          string `json:"podCIDR"`          // Pod CIDR
	APIServerAddress string `json:"apiServerAddress"` // API Server åœ°å€
	NetworkPlugin    string `json:"networkPlugin"`    // ç½‘ç»œæ’ä»¶
	ProxyMode        string `json:"proxyMode"`        // æœåŠ¡è½¬å‘æ¨¡å¼
	DNSService       string `json:"dnsService"`       // DNS æœåŠ¡
}

// ClusterComponentInfo é›†ç¾¤ç»„ä»¶ä¿¡æ¯
type ClusterComponentInfo struct {
	Components []ComponentInfo `json:"components"` // æ§åˆ¶å¹³é¢ç»„ä»¶
	Runtime    RuntimeInfo     `json:"runtime"`    // è¿è¡Œæ—¶ä¿¡æ¯
	Storage    []StorageInfo   `json:"storage"`    // å­˜å‚¨ä¿¡æ¯
}

// ComponentInfo ç»„ä»¶ä¿¡æ¯
type ComponentInfo struct {
	Name    string `json:"name"`    // ç»„ä»¶åç§°
	Version string `json:"version"` // ç‰ˆæœ¬
	Status  string `json:"status"`  // çŠ¶æ€
}

// RuntimeInfo è¿è¡Œæ—¶ä¿¡æ¯
type RuntimeInfo struct {
	ContainerRuntime string `json:"containerRuntime"` // å®¹å™¨è¿è¡Œæ—¶
	Version          string `json:"version"`          // ç‰ˆæœ¬
}

// StorageInfo å­˜å‚¨ä¿¡æ¯
type StorageInfo struct {
	Name          string `json:"name"`          // å­˜å‚¨åç§°
	Provisioner   string `json:"provisioner"`   // Provisioner
	ReclaimPolicy string `json:"reclaimPolicy"` // å›æ”¶ç­–ç•¥
}

// NetworkPolicyInfo ç½‘ç»œç­–ç•¥ä¿¡æ¯
type NetworkPolicyInfo struct {
	Name      string            `json:"name"`      // åç§°
	Namespace string            `json:"namespace"` // å‘½åç©ºé—´
	NetworkID string            `json:"networkID"` // ç½‘ç»œID (UID)
	Type      string            `json:"type"`      // ç±»å‹
	Status    string            `json:"status"`    // çŠ¶æ€
	Age       string            `json:"age"`       // åˆ›å»ºæ—¶é—´
	Labels    map[string]string `json:"labels"`    // æ ‡ç­¾
}

// EventInfo äº‹ä»¶ä¿¡æ¯
type EventInfo struct {
	Type           string             `json:"type"`           // äº‹ä»¶ç±»å‹: Normal, Warning
	Reason         string             `json:"reason"`         // åŸå› 
	Message        string             `json:"message"`        // æ¶ˆæ¯
	Source         string             `json:"source"`         // æ¥æº
	Count          int32              `json:"count"`          // æ¬¡æ•°
	FirstTimestamp string             `json:"firstTimestamp"` // é¦–æ¬¡å‘ç”Ÿæ—¶é—´
	LastTimestamp  string             `json:"lastTimestamp"`  // æœ€åå‘ç”Ÿæ—¶é—´
	InvolvedObject InvolvedObjectInfo `json:"involvedObject"` // å…³è”å¯¹è±¡
}

// InvolvedObjectInfo å…³è”å¯¹è±¡ä¿¡æ¯
type InvolvedObjectInfo struct {
	Kind      string `json:"kind"`
	Name      string `json:"name"`
	Namespace string `json:"namespace,omitempty"`
}

// ListNodes è·å–èŠ‚ç‚¹åˆ—è¡¨
func (h *ResourceHandler) ListNodes(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç™»å½•ç”¨æˆ· ID
	userIDVal, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒï¼šæ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯",
		})
		return
	}

	currentUserID, ok := userIDVal.(uint)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "ç”¨æˆ·IDç±»å‹é”™è¯¯",
		})
		return
	}

	// è°ƒè¯•æ—¥å¿—
	fmt.Printf("ğŸ” DEBUG [ListNodes]: clusterID=%d, currentUserID=%d\n", clusterID, currentUserID)

	// ä½¿ç”¨ç”¨æˆ·çš„å‡­æ®è·å– clientsetï¼ˆå®ç°æƒé™éš”ç¦»ï¼‰
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		fmt.Printf("âŒ DEBUG [ListNodes]: GetClientsetForUser failed for userID=%d: %v\n", currentUserID, err)
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [ListNodes]: Successfully got clientset for userID=%d\n", currentUserID)

	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "èŠ‚ç‚¹")
		return
	}

	// è·å–metrics clientset
	metricsClient, err := h.clusterService.GetCachedMetricsClientset(c.Request.Context(), uint(clusterID))
	if err != nil {
		fmt.Printf("âŒ DEBUG [ListNodes]: GetCachedMetricsClientset failed: %v\n", err)
		// ç»§ç»­æ‰§è¡Œï¼Œåªæ˜¯æ²¡æœ‰metricsæ•°æ®
		metricsClient = nil
	}

	// æ‰¹é‡è·å–æ‰€æœ‰èŠ‚ç‚¹çš„metrics
	nodeMetricsMap := make(map[string]*v1beta1.NodeMetrics)
	if metricsClient != nil {
		allNodeMetrics, err := metricsClient.MetricsV1beta1().NodeMetricses().List(c.Request.Context(), metav1.ListOptions{})
		if err == nil {
			fmt.Printf("âœ… DEBUG [ListNodes]: Successfully got %d node metrics\n", len(allNodeMetrics.Items))
			for _, nm := range allNodeMetrics.Items {
				nodeMetricsMap[nm.Name] = &nm
			}
		} else {
			fmt.Printf("âŒ DEBUG [ListNodes]: Failed to get node metrics: %v\n", err)
		}
	} else {
		fmt.Printf("âš ï¸  DEBUG [ListNodes]: metricsClient is nil\n")
	}

	// è·å–æ‰€æœ‰Podä»¥è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„Podæ•°é‡
	pods, err := clientset.CoreV1().Pods("").List(c.Request.Context(), metav1.ListOptions{})
	podCountMap := make(map[string]int)
	if err == nil {
		for _, pod := range pods.Items {
			if pod.Spec.NodeName != "" {
				podCountMap[pod.Spec.NodeName]++
			}
		}
	}

	nodeInfos := make([]NodeInfo, 0, len(nodes.Items))
	for _, node := range nodes.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := node.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		// ç¡®ä¿ annotations ä¸ä¸º nil
		annotations := node.Annotations
		if annotations == nil {
			annotations = make(map[string]string)
		}

		// è·å– Pod CIDR
		podCIDR := ""
		if len(node.Spec.PodCIDRs) > 0 {
			podCIDR = node.Spec.PodCIDRs[0]
		} else if node.Spec.PodCIDR != "" {
			podCIDR = node.Spec.PodCIDR
		}

		nodeInfo := NodeInfo{
			Name:             node.Name,
			Version:          node.Status.NodeInfo.KubeletVersion,
			OSImage:          node.Status.NodeInfo.OSImage,
			KernelVersion:    node.Status.NodeInfo.KernelVersion,
			ContainerRuntime: node.Status.NodeInfo.ContainerRuntimeVersion,
			Labels:           labels,
			Annotations:      annotations,
			PodCIDR:          podCIDR,
			ProviderID:       node.Spec.ProviderID,
		}

		// è·å–èŠ‚ç‚¹çŠ¶æ€
		for _, condition := range node.Status.Conditions {
			if condition.Type == v1.NodeReady {
				if condition.Status == v1.ConditionTrue {
					nodeInfo.Status = "Ready"
				} else {
					nodeInfo.Status = "NotReady"
				}
				break
			}
		}

		// è·å–IPåœ°å€ï¼ˆInternalIP å’Œ ExternalIPï¼‰
		for _, addr := range node.Status.Addresses {
			if addr.Type == v1.NodeInternalIP {
				nodeInfo.InternalIP = addr.Address
			} else if addr.Type == v1.NodeExternalIP {
				nodeInfo.ExternalIP = addr.Address
			}
		}

		// è®¡ç®—èŠ‚ç‚¹å¹´é¾„
		nodeInfo.Age = calculateAge(node.CreationTimestamp.Time)

		// è·å–è§’è‰²ï¼ˆä»Labelä¸­æ¨æ–­ï¼‰
		if _, ok := node.Labels["node-role.kubernetes.io/master"]; ok {
			nodeInfo.Roles = "master"
		} else if _, ok := node.Labels["node-role.kubernetes.io/control-plane"]; ok {
			nodeInfo.Roles = "control-plane"
		} else {
			nodeInfo.Roles = "worker"
		}

		// è·å–CPUå’Œå†…å­˜å®¹é‡
		cpuCapacity := node.Status.Capacity.Cpu().String()
		memoryCapacity := node.Status.Capacity.Memory().String()
		nodeInfo.CPUCapacity = cpuCapacity
		nodeInfo.MemoryCapacity = memoryCapacity

		// è·å–Podå®¹é‡ï¼ˆä¼˜å…ˆä½¿ç”¨Allocatableï¼Œå¦‚æœä¸º0åˆ™ä½¿ç”¨Capacityï¼Œå¦‚æœè¿˜æ˜¯0åˆ™ä½¿ç”¨é»˜è®¤å€¼110ï¼‰
		podCapacity := node.Status.Allocatable.Pods()
		podCapacityValue := int(podCapacity.Value())
		if podCapacityValue == 0 {
			podCapacity = node.Status.Capacity.Pods()
			podCapacityValue = int(podCapacity.Value())
		}
		// å¦‚æœè¿˜æ˜¯0ï¼Œä½¿ç”¨é»˜è®¤å€¼110ï¼ˆKubernetesé»˜è®¤çš„Podæ•°é‡é™åˆ¶ï¼‰
		if podCapacityValue == 0 {
			podCapacityValue = 110
		}
		nodeInfo.PodCapacity = podCapacityValue

		// è·å–Podæ•°é‡
		nodeInfo.PodCount = podCountMap[node.Name]

		// åˆ¤æ–­æ˜¯å¦å¯è°ƒåº¦
		nodeInfo.Schedulable = !node.Spec.Unschedulable

		// è·å–æ±¡ç‚¹æ•°é‡å’Œè¯¦æƒ…
		nodeInfo.TaintCount = len(node.Spec.Taints)
		nodeInfo.Taints = make([]TaintInfo, 0, len(node.Spec.Taints))
		for _, taint := range node.Spec.Taints {
			nodeInfo.Taints = append(nodeInfo.Taints, TaintInfo{
				Key:    taint.Key,
				Value:  taint.Value,
				Effect: string(taint.Effect),
			})
		}

		// å¡«å……Conditions
		nodeInfo.Conditions = make([]NodeCondition, 0, len(node.Status.Conditions))
		for _, cond := range node.Status.Conditions {
			nodeInfo.Conditions = append(nodeInfo.Conditions, NodeCondition{
				Type:               string(cond.Type),
				Status:             string(cond.Status),
				LastHeartbeatTime:  cond.LastHeartbeatTime.Format("2006-01-02 15:04:05"),
				LastTransitionTime: cond.LastTransitionTime.Format("2006-01-02 15:04:05"),
				Reason:             cond.Reason,
				Message:            cond.Message,
			})
		}

		// å¡«å……CPUå’Œå†…å­˜ä½¿ç”¨é‡
		if nodeMetrics, ok := nodeMetricsMap[node.Name]; ok {
			nodeInfo.CPUUsed = nodeMetrics.Usage.Cpu().MilliValue()
			nodeInfo.MemoryUsed = nodeMetrics.Usage.Memory().Value()
			fmt.Printf("ğŸ“Š DEBUG [ListNodes]: Node %s - CPUUsed: %d millicores, MemoryUsed: %d bytes\n",
				node.Name, nodeInfo.CPUUsed, nodeInfo.MemoryUsed)
		} else {
			fmt.Printf("âš ï¸  DEBUG [ListNodes]: No metrics found for node %s\n", node.Name)
		}

		nodeInfos = append(nodeInfos, nodeInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    nodeInfos,
	})
}

// GetNodeMetrics è·å–èŠ‚ç‚¹æŒ‡æ ‡
func (h *ResourceHandler) GetNodeMetrics(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	nodeName := c.Param("nodeName")

	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// è·å–å®¢æˆ·ç«¯
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		fmt.Printf("âŒ DEBUG [GetNodeMetrics]: GetClientsetForUser failed for userID=%d: %v\n", currentUserID, err)
		if h.handleGetClientsetError(c, err) {
			return
		}
		return
	}

	// è·å– metrics clientset
	metricsClient, err := h.clusterService.GetCachedMetricsClientset(c.Request.Context(), uint(clusterID))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å– metrics client å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–èŠ‚ç‚¹æŒ‡æ ‡
	nodeMetrics, err := metricsClient.MetricsV1beta1().NodeMetricses().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": fmt.Sprintf("è·å–èŠ‚ç‚¹æŒ‡æ ‡å¤±è´¥: %v", err),
		})
		return
	}

	// è·å–èŠ‚ç‚¹ä¿¡æ¯ä»¥è·å–å®¹é‡
	node, err := clientset.CoreV1().Nodes().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": fmt.Sprintf("è·å–èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥: %v", err),
		})
		return
	}

	// è®¡ç®—CPUä½¿ç”¨ç‡
	cpuUsage := float64(nodeMetrics.Usage.Cpu().MilliValue()) / float64(node.Status.Capacity.Cpu().MilliValue())
	memoryUsage := float64(nodeMetrics.Usage.Memory().Value()) / float64(node.Status.Capacity.Memory().Value())

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"cpuUsage":    cpuUsage,
			"memoryUsage": memoryUsage,
			"cpuUsed":     nodeMetrics.Usage.Cpu().MilliValue(),
			"memoryUsed":  nodeMetrics.Usage.Memory().Value(),
		},
	})
}

// ListNamespaces è·å–å‘½åç©ºé—´åˆ—è¡¨
func (h *ResourceHandler) ListNamespaces(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	namespaces, err := clientset.CoreV1().Namespaces().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "å‘½åç©ºé—´")
		return
	}

	namespaceInfos := make([]NamespaceInfo, 0, len(namespaces.Items))
	for _, ns := range namespaces.Items {
		nsInfo := NamespaceInfo{
			Name:   ns.Name,
			Labels: ns.Labels,
			Age:    calculateAge(ns.CreationTimestamp.Time),
		}

		// è·å–çŠ¶æ€
		if ns.Status.Phase == v1.NamespaceActive {
			nsInfo.Status = "Active"
		} else {
			nsInfo.Status = string(ns.Status.Phase)
		}

		namespaceInfos = append(namespaceInfos, nsInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    namespaceInfos,
	})
}

// ListPods è·å–Podåˆ—è¡¨
func (h *ResourceHandler) ListPods(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	nodeName := c.Query("nodeName")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	listOptions := metav1.ListOptions{}
	if nodeName != "" {
		listOptions.FieldSelector = "spec.nodeName=" + nodeName
	}

	pods, err := clientset.CoreV1().Pods(namespace).List(c.Request.Context(), listOptions)
	if err != nil {
		HandleK8sError(c, err, "Pod")
		return
	}

	podInfos := make([]PodInfo, 0, len(pods.Items))
	for _, pod := range pods.Items {
		podInfo := PodInfo{
			Name:      pod.Name,
			Namespace: pod.Namespace,
			Labels:    pod.Labels,
			Age:       calculateAge(pod.CreationTimestamp.Time),
			IP:        pod.Status.PodIP,
			Node:      pod.Spec.NodeName,
		}

		// è®¡ç®—ReadyçŠ¶æ€
		readyContainers := 0
		totalContainers := len(pod.Spec.Containers)
		for _, cs := range pod.Status.ContainerStatuses {
			if cs.Ready {
				readyContainers++
			}
			podInfo.Restarts += cs.RestartCount
		}
		podInfo.Ready = strconv.Itoa(readyContainers) + "/" + strconv.Itoa(totalContainers)

		// è·å–PodçŠ¶æ€
		podInfo.Status = string(pod.Status.Phase)

		podInfos = append(podInfos, podInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    podInfos,
	})
}

// ListDeployments è·å–Deploymentåˆ—è¡¨
func (h *ResourceHandler) ListDeployments(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	deployments, err := clientset.AppsV1().Deployments(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Deployment")
		return
	}

	deploymentInfos := make([]DeploymentInfo, 0, len(deployments.Items))
	for _, deploy := range deployments.Items {
		deployInfo := DeploymentInfo{
			Name:      deploy.Name,
			Namespace: deploy.Namespace,
			UpToDate:  deploy.Status.UpdatedReplicas,
			Available: deploy.Status.AvailableReplicas,
			Age:       calculateAge(deploy.CreationTimestamp.Time),
			Replicas:  *deploy.Spec.Replicas,
			Selector:  deploy.Spec.Selector.MatchLabels,
			Labels:    deploy.Labels,
		}

		// è®¡ç®—ReadyçŠ¶æ€
		readyReplicas := deploy.Status.ReadyReplicas
		totalReplicas := *deploy.Spec.Replicas
		deployInfo.Ready = strconv.Itoa(int(readyReplicas)) + "/" + strconv.Itoa(int(totalReplicas))

		deploymentInfos = append(deploymentInfos, deployInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    deploymentInfos,
	})
}

// GetClusterStats è·å–é›†ç¾¤ç»Ÿè®¡ä¿¡æ¯
func (h *ResourceHandler) GetClusterStats(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å– metrics clientset
	metricsClient, err := h.clusterService.GetCachedMetricsClientset(c.Request.Context(), uint(clusterID))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å– metrics client å¤±è´¥: " + err.Error(),
		})
		return
	}

	stats := ClusterStats{}

	// è·å–èŠ‚ç‚¹ä¿¡æ¯
	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹åˆ—è¡¨å¤±è´¥: " + err.Error(),
		})
		return
	}
	stats.NodeCount = len(nodes.Items)

	// è®¡ç®—CPUå’Œå†…å­˜æ€»é‡åŠå¯åˆ†é…é‡
	var totalCPUCapacity, totalMemoryCapacity float64
	var totalCPUAllocatable, totalMemoryAllocatable float64

	for _, node := range nodes.Items {
		cpuCapacity := node.Status.Capacity.Cpu().AsApproximateFloat64()
		memoryCapacity := float64(node.Status.Capacity.Memory().Value())
		cpuAllocatable := node.Status.Allocatable.Cpu().AsApproximateFloat64()
		memoryAllocatable := float64(node.Status.Allocatable.Memory().Value())

		totalCPUCapacity += cpuCapacity
		totalMemoryCapacity += memoryCapacity
		totalCPUAllocatable += cpuAllocatable
		totalMemoryAllocatable += memoryAllocatable
	}

	stats.CPUCapacity = totalCPUCapacity
	stats.MemoryCapacity = totalMemoryCapacity
	stats.CPUAllocatable = totalCPUAllocatable
	stats.MemoryAllocatable = totalMemoryAllocatable

	// è·å–èŠ‚ç‚¹æŒ‡æ ‡ï¼ˆMetrics APIï¼‰
	nodeMetrics, err := metricsClient.MetricsV1beta1().NodeMetricses().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹æŒ‡æ ‡å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è®¡ç®—å®é™…ä½¿ç”¨çš„CPUå’Œå†…å­˜
	var totalCPUUsed, totalMemoryUsed float64
	for _, nodeMetric := range nodeMetrics.Items {
		cpuUsed := nodeMetric.Usage.Cpu().AsApproximateFloat64()
		memoryUsed := float64(nodeMetric.Usage.Memory().Value())
		totalCPUUsed += cpuUsed
		totalMemoryUsed += memoryUsed
	}

	// è®¾ç½®å·²ä½¿ç”¨é‡
	stats.CPUUsed = totalCPUUsed
	stats.MemoryUsed = totalMemoryUsed

	// è®¡ç®—ä½¿ç”¨ç‡ç™¾åˆ†æ¯”ï¼ˆåŸºäº Allocatableï¼‰
	if totalCPUAllocatable > 0 {
		stats.CPUUsage = (totalCPUUsed / totalCPUAllocatable) * 100
	}
	if totalMemoryAllocatable > 0 {
		stats.MemoryUsage = (totalMemoryUsed / totalMemoryAllocatable) * 100
	}

	// è·å–Podæ•°é‡
	pods, err := clientset.CoreV1().Pods("").List(c.Request.Context(), metav1.ListOptions{})
	if err == nil {
		stats.PodCount = len(pods.Items)
	}

	// è·å–Deploymentæ•°é‡
	deployments, err := clientset.AppsV1().Deployments("").List(c.Request.Context(), metav1.ListOptions{})
	deploymentCount := 0
	if err == nil {
		deploymentCount = len(deployments.Items)
	}

	// è·å–DaemonSetæ•°é‡
	daemonsets, err := clientset.AppsV1().DaemonSets("").List(c.Request.Context(), metav1.ListOptions{})
	daemonsetCount := 0
	if err == nil {
		daemonsetCount = len(daemonsets.Items)
	}

	// è·å–StatefulSetæ•°é‡
	statefulsets, err := clientset.AppsV1().StatefulSets("").List(c.Request.Context(), metav1.ListOptions{})
	statefulsetCount := 0
	if err == nil {
		statefulsetCount = len(statefulsets.Items)
	}

	// è·å–Jobæ•°é‡
	jobs, err := clientset.BatchV1().Jobs("").List(c.Request.Context(), metav1.ListOptions{})
	jobCount := 0
	if err == nil {
		jobCount = len(jobs.Items)
	}

	// å·¥ä½œè´Ÿè½½æ€»æ•° = Deployment + DaemonSet + StatefulSet + Job
	stats.WorkloadCount = deploymentCount + daemonsetCount + statefulsetCount + jobCount

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    stats,
	})
}

// GetClusterNetworkInfo è·å–é›†ç¾¤ç½‘ç»œä¿¡æ¯
func (h *ResourceHandler) GetClusterNetworkInfo(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	networkInfo := ClusterNetworkInfo{}

	// è·å–é›†ç¾¤çš„ API Endpoint
	apiEndpoint, err := h.clusterService.GetClusterAPIEndpoint(c.Request.Context(), uint(clusterID))
	if err == nil && apiEndpoint != "" {
		networkInfo.APIServerAddress = apiEndpoint
	}

	// è·å–èŠ‚ç‚¹ä¿¡æ¯æ¥æ¨æ–­ç½‘ç»œé…ç½®
	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err == nil && len(nodes.Items) > 0 {
		node := nodes.Items[0]

		// è·å– Pod CIDR
		if podCIDR := node.Spec.PodCIDR; podCIDR != "" {
			networkInfo.PodCIDR = podCIDR
		}
	}

	// è·å– CNI ç½‘ç»œæ’ä»¶ï¼ˆä» kube-system å‘½åç©ºé—´çš„ DaemonSet ä¸­æ£€æµ‹ï¼‰
	daemonSets, err := clientset.AppsV1().DaemonSets("kube-system").List(c.Request.Context(), metav1.ListOptions{})
	if err == nil {
		// å¸¸è§çš„ CNI æ’ä»¶æ ‡è¯†
		cniPlugins := map[string]string{
			"calico":          "Calico",
			"flannel":         "Flannel",
			"weave":           "Weave",
			"canal":           "Canal",
			"cilium":          "Cilium",
			"contiv":          "Contiv",
			"kube-router":     "Kube-Router",
			"amazon-vpc-cni":  "AWS VPC CNI",
			"azure-cniplugin": "Azure CNI",
			"vsphere-cni":     "vSphere CNI",
			"tke-cni":         "TKE CNI",
			"tke-bridge":      "TKE Bridge",
			"networkpolicy":   "TKE NetworkPolicy",
		}

		for _, ds := range daemonSets.Items {
			dsName := strings.ToLower(ds.Name)
			for key, name := range cniPlugins {
				if strings.Contains(dsName, key) {
					networkInfo.NetworkPlugin = name
					break
				}
			}
			if networkInfo.NetworkPlugin != "" {
				break
			}
		}
	}

	// è·å– kube-proxy çš„ proxy æ¨¡å¼ï¼ˆä» DaemonSet çš„å‘½ä»¤è¡Œå‚æ•°ã€ç¯å¢ƒå˜é‡æˆ– ConfigMap ä¸­è·å–ï¼‰
	kubeProxyDS, err := clientset.AppsV1().DaemonSets("kube-system").Get(c.Request.Context(), "kube-proxy", metav1.GetOptions{})
	if err == nil && len(kubeProxyDS.Spec.Template.Spec.Containers) > 0 {
		container := kubeProxyDS.Spec.Template.Spec.Containers[0]

		// 1. ä»å‘½ä»¤è¡Œå‚æ•°ä¸­æŸ¥æ‰¾ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
		for _, arg := range container.Command {
			if strings.Contains(arg, "--proxy-mode=") {
				mode := strings.TrimPrefix(arg, "--proxy-mode=")
				networkInfo.ProxyMode = mode
				break
			}
		}

		// 2. ä»å‘½ä»¤è¡Œå‚æ•°ä¸­æŸ¥æ‰¾ï¼ˆç©ºæ ¼åˆ†éš”ï¼‰
		if networkInfo.ProxyMode == "" && len(container.Command) > 0 {
			for i, arg := range container.Command {
				if arg == "--proxy-mode" && i+1 < len(container.Command) {
					networkInfo.ProxyMode = container.Command[i+1]
					break
				}
			}
		}

		// 3. ä»ç¯å¢ƒå˜é‡ä¸­æŸ¥æ‰¾
		if networkInfo.ProxyMode == "" {
			for _, env := range container.Env {
				if env.Name == "KUBE_PROXY_MODE" {
					networkInfo.ProxyMode = env.Value
					break
				}
			}
		}
	}

	// å¦‚æœæ²¡æ‰¾åˆ°ï¼Œä» ConfigMap ä¸­æŸ¥æ‰¾
	if networkInfo.ProxyMode == "" {
		kubeProxyCM, err := clientset.CoreV1().ConfigMaps("kube-system").Get(c.Request.Context(), "kube-proxy", metav1.GetOptions{})
		if err == nil {
			// æ£€æŸ¥ config.yaml
			if config, ok := kubeProxyCM.Data["config.yaml"]; ok {
				// æŸ¥æ‰¾ proxyMode
				if idx := strings.Index(config, "proxyMode:"); idx >= 0 {
					start := idx + 10 // è·³è¿‡ "proxyMode:"
					remaining := config[start:]
					// æå–åˆ°è¡Œå°¾æˆ–æ³¨é‡Š
					if end := strings.IndexAny(remaining, "\n#"); end > 0 {
						modeStr := strings.TrimSpace(remaining[:end])
						modeStr = strings.Trim(modeStr, `"`)
						networkInfo.ProxyMode = modeStr
					}
				}
			}
			// æ£€æŸ¥ config.conf (Kubernetes 1.10+ ä½¿ç”¨è¿™ä¸ªæ ¼å¼)
			if config, ok := kubeProxyCM.Data["config.conf"]; ok {
				if idx := strings.Index(config, "proxyMode"); idx >= 0 {
					start := idx + 10 // è·³è¿‡ "proxyMode" æˆ– "proxyMode:"
					remaining := config[start:]
					// è·³è¿‡å¯èƒ½çš„å†’å·å’Œç­‰å·
					remaining = strings.TrimLeft(remaining, ":=")
					remaining = strings.TrimSpace(remaining)
					// æå–å€¼åˆ°è¡Œå°¾æˆ–é€—å·
					if end := strings.IndexAny(remaining, "\n,"); end > 0 {
						modeStr := strings.TrimSpace(remaining[:end])
						modeStr = strings.Trim(modeStr, `"`)
						networkInfo.ProxyMode = modeStr
					}
				}
			}
			if configJSON, ok := kubeProxyCM.Data["config.json"]; ok {
				// JSON æ ¼å¼é…ç½®
				if idx := strings.Index(configJSON, "proxyMode"); idx > 0 {
					start := idx + 11 // è·³è¿‡ "proxyMode:"
					if end := strings.Index(configJSON[start:], ","); end > 0 {
						modeStr := strings.TrimSpace(configJSON[start : start+end])
						modeStr = strings.Trim(modeStr, `"`)
						networkInfo.ProxyMode = modeStr
					}
				}
			}
		}
	}

	// é»˜è®¤å€¼ä¸º ipvsï¼ˆç°ä»£ Kubernetes çš„é»˜è®¤æ¨¡å¼ï¼‰
	if networkInfo.ProxyMode == "" {
		// å°è¯•ä»èŠ‚ç‚¹ä¿¡æ¯æ¨æ–­ï¼ˆä¸æ˜¯100%å‡†ç¡®ï¼‰
		nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
		if err == nil && len(nodes.Items) > 0 {
			// æ£€æŸ¥å†…æ ¸æ¨¡å—æˆ–ç³»ç»Ÿä¿¡æ¯æ¥åˆ¤æ–­
			// ä½†è¿™æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€å•ä½¿ç”¨é»˜è®¤å€¼
			networkInfo.ProxyMode = "ipvs"
		}
	}

	// è·å– kube-apiserver æœåŠ¡
	apiServerSvc, err := clientset.CoreV1().Services("default").Get(c.Request.Context(), "kubernetes", metav1.GetOptions{})
	if err == nil && apiServerSvc != nil {
		// è·å– Service CIDR (ä» ClusterIPs æ¨æ–­)
		if len(apiServerSvc.Spec.ClusterIPs) > 0 {
			// é€šå¸¸æ˜¯ç¬¬ä¸€ä¸ª IPï¼Œä½†æˆ‘ä»¬å¯ä»¥æ¨æ–­ CIDR
			// ä¾‹å¦‚ï¼š10.0.0.1 å¯èƒ½æ˜¯ 10.0.0.0/24 æˆ– 10.0.0.0/16
			ip := apiServerSvc.Spec.ClusterIPs[0]
			// ç®€åŒ–å¤„ç†ï¼Œç›´æ¥æ˜¾ç¤ºç¬¬ä¸€ä¸ª ClusterIP
			networkInfo.ServiceCIDR = ip
		}
	}

	// è·å– DNS æœåŠ¡
	_, err = clientset.CoreV1().Services("kube-system").Get(c.Request.Context(), "kube-dns", metav1.GetOptions{})
	if err == nil {
		networkInfo.DNSService = "CoreDNS"
	} else {
		// å°è¯•è·å–å…¶ä»– DNS å®ç°
		svcs, _ := clientset.CoreV1().Services("kube-system").List(c.Request.Context(), metav1.ListOptions{})
		for _, svc := range svcs.Items {
			if strings.Contains(svc.Name, "dns") {
				networkInfo.DNSService = svc.Name
				break
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    networkInfo,
	})
}

// GetClusterComponentInfo è·å–é›†ç¾¤ç»„ä»¶ä¿¡æ¯
func (h *ResourceHandler) GetClusterComponentInfo(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	componentInfo := ClusterComponentInfo{
		Components: []ComponentInfo{},
	}

	// è·å–èŠ‚ç‚¹ä¿¡æ¯æ¥è·å–è¿è¡Œæ—¶
	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err == nil && len(nodes.Items) > 0 {
		node := nodes.Items[0]
		componentInfo.Runtime = RuntimeInfo{
			ContainerRuntime: node.Status.NodeInfo.ContainerRuntimeVersion,
			Version:          node.Status.NodeInfo.KubeletVersion,
		}
	}

	// è·å–æ§åˆ¶å¹³é¢ç»„ä»¶ Pod
	pods, err := clientset.CoreV1().Pods("kube-system").List(c.Request.Context(), metav1.ListOptions{})
	if err == nil {
		// å¸¸è§çš„æ§åˆ¶å¹³é¢ç»„ä»¶ï¼ˆæ”¯æŒå¤šç§å‘½åæ–¹å¼ï¼‰
		controlPlanePatterns := map[string]string{
			"kube-apiserver":          "API Server",
			"kube-apiserver-":         "API Server",
			"apiserver":               "API Server",
			"kube-controller":         "Controller Manager",
			"kube-controller-":        "Controller Manager",
			"kube-controller-manager": "Controller Manager",
			"cloud-controller":        "Cloud Controller",
			"cloud-controller-":       "Cloud Controller",
			"kube-scheduler":          "Scheduler",
			"kube-scheduler-":         "Scheduler",
			"scheduler":               "Scheduler",
			"etcd":                    "etcd",
			"etcd-":                   "etcd",
			"coredns":                 "CoreDNS",
			"coredns-":                "CoreDNS",
		}

		componentMap := make(map[string]ComponentInfo)

		// è°ƒè¯•æ—¥å¿—ï¼šæ‰“å° kube-system å‘½åç©ºé—´ä¸‹çš„æ‰€æœ‰ Pod
		log.Printf("[GetComponentInfo] kube-system namespace has %d pods", len(pods.Items))
		for _, pod := range pods.Items {
			log.Printf("[GetComponentInfo] Found pod: %s (OwnerReferences: %d)",
				pod.Name, len(pod.OwnerReferences))
		}

		for _, pod := range pods.Items {
			podName := strings.ToLower(pod.Name)
			var componentName string
			var componentKey string

			// æ’é™¤éæ§åˆ¶å¹³é¢ç»„ä»¶ï¼ˆCNIã€ç½‘ç»œæ’ä»¶ç­‰ï¼‰
			if strings.Contains(podName, "calico") ||
				strings.Contains(podName, "flannel") ||
				strings.Contains(podName, "kube-proxy") ||
				strings.Contains(podName, "metrics-server") {
				continue
			}

			// è¯†åˆ«ç»„ä»¶ï¼ˆæ”¯æŒå‰ç¼€åŒ¹é…å’ŒåŒ…å«åŒ¹é…ï¼‰
			for pattern, name := range controlPlanePatterns {
				matched := false
				if strings.HasSuffix(pattern, "-") {
					// å‰ç¼€åŒ¹é…æ¨¡å¼
					matched = strings.HasPrefix(podName, pattern)
				} else {
					// ç²¾ç¡®åŒ¹é…æˆ–åŒ…å«åŒ¹é…
					matched = strings.HasPrefix(podName, pattern) ||
						strings.Contains(podName, pattern)
				}

				if matched {
					// å†æ¬¡æ£€æŸ¥ï¼Œç¡®ä¿ä¸æ˜¯ CNI ç»„ä»¶
					if strings.Contains(podName, "calico") || strings.Contains(podName, "controllers") {
						if !strings.HasPrefix(podName, "kube-controller") {
							continue
						}
					}

					// ä½¿ç”¨æ›´å…·ä½“çš„keyé¿å…é‡å¤
					if pattern == "kube-apiserver" || pattern == "kube-apiserver-" {
						componentKey = "kube-apiserver"
					} else if pattern == "kube-controller" || pattern == "kube-controller-" || pattern == "kube-controller-manager" {
						componentKey = "kube-controller"
					} else if pattern == "kube-scheduler" || pattern == "kube-scheduler-" {
						componentKey = "kube-scheduler"
					} else if strings.HasPrefix(pattern, "etcd") {
						componentKey = "etcd"
					} else if strings.HasPrefix(pattern, "coredns") {
						componentKey = "coredns"
					} else if strings.HasPrefix(pattern, "cloud-controller") {
						componentKey = "cloud-controller"
					}
					componentName = name
					log.Printf("[GetComponentInfo] Matched pod %s to component %s (pattern: %s)",
						pod.Name, componentName, pattern)
					break
				}
			}

			if componentName == "" {
				continue
			}

			// è·å–ç‰ˆæœ¬
			version := "unknown"
			if len(pod.Spec.Containers) > 0 {
				// å°è¯•ä» Image ä¸­æå–ç‰ˆæœ¬
				image := pod.Spec.Containers[0].Image
				if idx := strings.LastIndex(image, ":"); idx > 0 {
					version = image[idx+1:]
				} else {
					version = image
				}
			}

			// è·å–çŠ¶æ€
			status := "Running"
			if pod.Status.Phase != v1.PodRunning {
				status = string(pod.Status.Phase)
			}

			componentMap[componentKey] = ComponentInfo{
				Name:    componentName,
				Version: version,
				Status:  status,
			}
			log.Printf("[GetComponentInfo] Added component: %s (version: %s, status: %s)",
				componentName, version, status)
		}

		// è½¬æ¢ä¸ºåˆ‡ç‰‡
		for _, comp := range componentMap {
			componentInfo.Components = append(componentInfo.Components, comp)
		}
		log.Printf("[GetComponentInfo] Total components found from pods: %d", len(componentInfo.Components))
	} else {
		log.Printf("[GetComponentInfo] Failed to list pods in kube-system: %v", err)
	}

	// å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ§åˆ¶å¹³é¢ç»„ä»¶ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶éƒ¨ç½²çš„é›†ç¾¤ï¼ˆsystemd å¯åŠ¨ï¼‰
	// å°è¯•é€šè¿‡èŠ‚ç‚¹æ ‡ç­¾å’Œç‰ˆæœ¬ä¿¡æ¯æ¥æ¨æ–­
	log.Printf("[GetComponentInfo] Checking for binary deployment cluster...")

	// æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æ§åˆ¶å¹³é¢ç»„ä»¶ï¼ˆAPI Server, Scheduler, Controller Manager, etcdï¼‰
	hasControlPlanePods := false
	for _, comp := range componentInfo.Components {
		if comp.Name == "API Server" || comp.Name == "Scheduler" ||
			comp.Name == "Controller Manager" || comp.Name == "etcd" {
			hasControlPlanePods = true
			break
		}
	}

	if !hasControlPlanePods {
		log.Printf("[GetComponentInfo] No control plane pods found, checking for binary deployment...")

		// è·å–é›†ç¾¤ç‰ˆæœ¬ä¿¡æ¯
		serverVersion, err := clientset.Discovery().ServerVersion()
		if err == nil {
			k8sVersion := serverVersion.GitVersion
			log.Printf("[GetComponentInfo] Kubernetes version: %s", k8sVersion)

			// è·å–æ‰€æœ‰èŠ‚ç‚¹
			nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
			if err == nil {
				hasControlPlaneNode := false
				for _, node := range nodes.Items {
					nodeName := strings.ToLower(node.Name)
					log.Printf("[GetComponentInfo] Checking node: %s", node.Name)

					// æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æ˜¯ master/control-plane èŠ‚ç‚¹
					if _, hasControlPlane := node.Labels["node-role.kubernetes.io/control-plane"]; hasControlPlane {
						log.Printf("[GetComponentInfo] Found control-plane node by label: %s", node.Name)
						hasControlPlaneNode = true
						break
					}
					// å…¼å®¹æ—§çš„æ ‡ç­¾
					if _, hasMaster := node.Labels["node-role.kubernetes.io/master"]; hasMaster {
						log.Printf("[GetComponentInfo] Found master node by label: %s", node.Name)
						hasControlPlaneNode = true
						break
					}

					// å¦‚æœèŠ‚ç‚¹åç§°åŒ…å« master/control-plane/mgr ç­‰å…³é”®è¯ï¼Œä¹Ÿè®¤ä¸ºæ˜¯æ§åˆ¶å¹³é¢èŠ‚ç‚¹
					if strings.Contains(nodeName, "master") ||
						strings.Contains(nodeName, "control-plane") ||
						strings.Contains(nodeName, "control") ||
						strings.Contains(nodeName, "mgr") {
						log.Printf("[GetComponentInfo] Found control-plane node by name pattern: %s", node.Name)
						hasControlPlaneNode = true
						break
					}
				}

				// å¦‚æœæ£€æµ‹åˆ°æ§åˆ¶å¹³é¢èŠ‚ç‚¹ä½†æ²¡æœ‰æ‰¾åˆ°æ§åˆ¶å¹³é¢ Podï¼Œè¯´æ˜æ˜¯äºŒè¿›åˆ¶éƒ¨ç½²
				if hasControlPlaneNode {
					log.Printf("[GetComponentInfo] Detected binary deployment cluster, adding components...")

					// æ·»åŠ  API Server
					componentInfo.Components = append(componentInfo.Components, ComponentInfo{
						Name:    "API Server",
						Version: serverVersion.GitVersion,
						Status:  "Running",
					})

					// æ·»åŠ  Scheduler
					componentInfo.Components = append(componentInfo.Components, ComponentInfo{
						Name:    "Scheduler",
						Version: serverVersion.GitVersion,
						Status:  "Running",
					})

					// æ·»åŠ  Controller Manager
					componentInfo.Components = append(componentInfo.Components, ComponentInfo{
						Name:    "Controller Manager",
						Version: serverVersion.GitVersion,
						Status:  "Running",
					})

					// æ·»åŠ  etcdï¼ˆç‰ˆæœ¬æœªçŸ¥ï¼‰
					componentInfo.Components = append(componentInfo.Components, ComponentInfo{
						Name:    "etcd",
						Version: "unknown",
						Status:  "Running",
					})

					log.Printf("[GetComponentInfo] Added 4 control plane components for binary deployment")
				} else {
					log.Printf("[GetComponentInfo] No control-plane node found, skipping binary deployment detection")
				}
			}
		}
	}

	// è·å–å­˜å‚¨ç±»
	storageClasses, err := clientset.StorageV1().StorageClasses().List(c.Request.Context(), metav1.ListOptions{})
	if err == nil {
		for _, sc := range storageClasses.Items {
			componentInfo.Storage = append(componentInfo.Storage, StorageInfo{
				Name:          sc.Name,
				Provisioner:   sc.Provisioner,
				ReclaimPolicy: string(*sc.ReclaimPolicy),
			})
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    componentInfo,
	})
}

// ListEvents è·å–äº‹ä»¶åˆ—è¡¨
func (h *ResourceHandler) ListEvents(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	fieldSelector := c.Query("fieldSelector")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ„å»ºListOptionsï¼Œé™åˆ¶è¿”å›50æ¡äº‹ä»¶
	listOptions := metav1.ListOptions{
		Limit: 50,
	}

	// æ·»åŠ  fieldSelector è¿‡æ»¤
	if fieldSelector != "" {
		listOptions.FieldSelector = fieldSelector
	}

	var events *v1.EventList
	if namespace != "" {
		// è·å–æŒ‡å®šå‘½åç©ºé—´çš„äº‹ä»¶
		events, err = clientset.CoreV1().Events(namespace).List(c.Request.Context(), listOptions)
	} else {
		// è·å–æ‰€æœ‰å‘½åç©ºé—´çš„äº‹ä»¶
		events, err = clientset.CoreV1().Events("").List(c.Request.Context(), listOptions)
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–äº‹ä»¶åˆ—è¡¨å¤±è´¥: " + err.Error(),
		})
		return
	}

	eventInfos := make([]EventInfo, 0, len(events.Items))
	for _, event := range events.Items {
		// è·å–æ¥æºä¿¡æ¯
		source := event.Source.Component
		if event.Source.Host != "" {
			source = source + " (" + event.Source.Host + ")"
		}

		eventInfo := EventInfo{
			Type:    event.Type,
			Reason:  event.Reason,
			Message: event.Message,
			Source:  source,
			Count:   event.Count,
			InvolvedObject: InvolvedObjectInfo{
				Kind:      event.InvolvedObject.Kind,
				Name:      event.InvolvedObject.Name,
				Namespace: event.InvolvedObject.Namespace,
			},
		}

		// æ ¼å¼åŒ–æ—¶é—´
		if !event.FirstTimestamp.IsZero() {
			eventInfo.FirstTimestamp = event.FirstTimestamp.Format("2006-01-02 15:04:05")
		}
		if !event.LastTimestamp.IsZero() {
			eventInfo.LastTimestamp = event.LastTimestamp.Format("2006-01-02 15:04:05")
		} else if !event.EventTime.IsZero() {
			eventInfo.LastTimestamp = event.EventTime.Format("2006-01-02 15:04:05")
		}

		eventInfos = append(eventInfos, eventInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    eventInfos,
	})
}

// GetAPIGroups è·å–é›†ç¾¤çš„APIç»„åˆ—è¡¨
// @Summary è·å–APIç»„åˆ—è¡¨
// @Description è·å–Kubernetesé›†ç¾¤æ‰€æœ‰å¯ç”¨çš„APIç»„
// @Tags Kubernetes/Resources
// @Accept json
// @Produce json
// @Param clusterId query int true "é›†ç¾¤ID"
// @Success 200 {object} Response
// @Router /api/v1/plugins/kubernetes/resources/api-groups [get]
func (h *ResourceHandler) GetAPIGroups(c *gin.Context) {
	clusterIdStr := c.Query("clusterId")
	if clusterIdStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘é›†ç¾¤IDå‚æ•°",
		})
		return
	}

	clusterId, err := strconv.ParseUint(clusterIdStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// è·å–é›†ç¾¤çš„ clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterId), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥",
		})
		return
	}

	// è·å–æ‰€æœ‰APIç»„
	discoveryClient := clientset.Discovery()
	apiGroupList, err := discoveryClient.ServerGroups()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–APIç»„å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ”¶é›†æ‰€æœ‰APIç»„åç§°
	apiGroups := make(map[string]bool)
	apiGroups["core"] = true // core API ç”¨ "core" è¡¨ç¤º

	for _, group := range apiGroupList.Groups {
		apiGroups[group.Name] = true
	}

	// è½¬æ¢ä¸ºåˆ‡ç‰‡å¹¶æ’åºï¼ˆcore æ”¾åœ¨æœ€å‰é¢ï¼‰
	groupList := make([]string, 0, len(apiGroups))
	// å…ˆæ·»åŠ  core
	groupList = append(groupList, "core")
	// å†æ·»åŠ å…¶ä»–ç»„ï¼ˆæŒ‰å­—æ¯æ’åºï¼‰
	for group := range apiGroups {
		if group != "core" {
			groupList = append(groupList, group)
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    groupList,
	})
}

// GetResourcesByAPIGroup æ ¹æ®APIç»„è·å–èµ„æºåˆ—è¡¨
// @Summary æ ¹æ®APIç»„è·å–èµ„æºåˆ—è¡¨
// @Description æ ¹æ®é€‰å®šçš„APIç»„åˆ—è¡¨è·å–æ‰€æœ‰è¿™äº›ç»„ä¸‹çš„èµ„æºç±»å‹
// @Tags Kubernetes/Resources
// @Accept json
// @Produce json
// @Param clusterId query int true "é›†ç¾¤ID"
// @Param apiGroups query string true "APIç»„åˆ—è¡¨ï¼ˆé€—å·åˆ†éš”ï¼‰"
// @Success 200 {object} Response
// @Router /api/v1/plugins/kubernetes/resources/api-resources [get]
func (h *ResourceHandler) GetResourcesByAPIGroup(c *gin.Context) {
	clusterIdStr := c.Query("clusterId")
	if clusterIdStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘é›†ç¾¤IDå‚æ•°",
		})
		return
	}

	clusterId, err := strconv.ParseUint(clusterIdStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	apiGroupsStr := c.Query("apiGroups")
	if apiGroupsStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘APIç»„å‚æ•°",
		})
		return
	}

	// è§£æAPIç»„åˆ—è¡¨
	apiGroups := strings.Split(apiGroupsStr, ",")
	// å°† "core" è½¬æ¢ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆKubernetes core API group çš„æ­£ç¡®è¡¨ç¤ºï¼‰
	for i, group := range apiGroups {
		if strings.TrimSpace(group) == "core" {
			apiGroups[i] = ""
		}
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// è·å–é›†ç¾¤çš„ clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterId), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥",
		})
		return
	}

	// è·å–æ‰€æœ‰APIèµ„æºå’Œç‰ˆæœ¬
	discoveryClient := clientset.Discovery()
	_, resourceLists, err := discoveryClient.ServerGroupsAndResources()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èµ„æºåˆ—è¡¨å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ä½¿ç”¨mapå»é‡
	resourceMap := make(map[string]bool)

	// æ”¶é›†æ‰€æœ‰æŒ‡å®šAPIç»„çš„èµ„æº
	for _, resourceList := range resourceLists {
		// æå–GroupVersionä¸­çš„ç»„å
		groupVersion := resourceList.GroupVersion
		groupName := ""
		if strings.Contains(groupVersion, "/") {
			parts := strings.Split(groupVersion, "/")
			if len(parts) == 2 {
				groupName = parts[0]
			}
		}

		// æ£€æŸ¥æ˜¯å¦åœ¨è¯·æ±‚çš„APIç»„åˆ—è¡¨ä¸­
		matched := false
		for _, apiGroup := range apiGroups {
			apiGroup = strings.TrimSpace(apiGroup)
			if apiGroup == "" {
				// ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºcoreç»„ï¼ŒåŒ¹é… v1
				if groupVersion == "v1" {
					matched = true
					break
				}
			} else if groupName == apiGroup || groupVersion == apiGroup {
				matched = true
				break
			}
		}

		if matched {
			for _, resource := range resourceList.APIResources {
				// è¿‡æ»¤æ‰å­èµ„æºï¼ˆå¦‚ pods/status, pods/log ç­‰ï¼‰
				if !strings.Contains(resource.Name, "/") {
					resourceMap[resource.Name] = true
				}
			}
		}
	}

	// è½¬æ¢ä¸ºåˆ‡ç‰‡
	resources := make([]string, 0, len(resourceMap))
	for resource := range resourceMap {
		resources = append(resources, resource)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    resources,
	})
}

// GetNodeYAML è·å–èŠ‚ç‚¹YAML
func (h *ResourceHandler) GetNodeYAML(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	fmt.Printf("ğŸ” DEBUG [GetNodeYAML]: clusterIDStr=%s\n", clusterIDStr)

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: Invalid clusterID: %v\n", err)
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	nodeName := c.Param("nodeName")
	if nodeName == "" {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: Empty nodeName\n")
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	fmt.Printf("ğŸ” DEBUG [GetNodeYAML]: nodeName=%s, clusterID=%d\n", nodeName, clusterID)

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: No user_id in context\n")
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	fmt.Printf("âœ… DEBUG [GetNodeYAML]: userID=%v\n", currentUserID)

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID.(uint))
	if err != nil {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: GetClientsetForUser failed: %v\n", err)
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [GetNodeYAML]: Got clientset\n")

	// è·å–èŠ‚ç‚¹
	node, err := clientset.CoreV1().Nodes().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: Get node failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [GetNodeYAML]: Got node %s\n", node.Name)

	// æ¸…ç†ä¸éœ€è¦çš„å­—æ®µ
	cleanedNode := cleanNodeForYAML(node)

	// è½¬æ¢ä¸ºYAML
	yamlBytes, err := yamlMarshal(cleanedNode)
	if err != nil {
		fmt.Printf("âŒ DEBUG [GetNodeYAML]: Marshal YAML failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è½¬æ¢YAMLå¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [GetNodeYAML]: YAML marshaled successfully, length=%d\n", len(yamlBytes))

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"yaml": string(yamlBytes),
		},
	})
}

// UpdateNodeYAMLRequest æ›´æ–°èŠ‚ç‚¹YAMLè¯·æ±‚
type UpdateNodeYAMLRequest struct {
	ClusterID int    `json:"clusterId" binding:"required"`
	YAML      string `json:"yaml" binding:"required"`
}

// UpdateNodeYAML æ›´æ–°èŠ‚ç‚¹YAML
func (h *ResourceHandler) UpdateNodeYAML(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	var req UpdateNodeYAMLRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è§£æYAMLä¸ºmap
	var yamlData map[string]interface{}
	if err := yamlUnmarshal([]byte(req.YAML), &yamlData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æYAMLå¤±è´¥: " + err.Error(),
		})
		return
	}

	// éªŒè¯èŠ‚ç‚¹åç§°
	if metadata, ok := yamlData["metadata"].(map[string]interface{}); ok {
		if name, ok := metadata["name"].(string); ok && name != nodeName {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "YAMLä¸­çš„èŠ‚ç‚¹åç§°ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
	}

	// æå–æ–°çš„ labels
	var newLabels map[string]string
	if metadata, ok := yamlData["metadata"].(map[string]interface{}); ok {
		if labels, ok := metadata["labels"].(map[string]interface{}); ok {
			newLabels = make(map[string]string)
			for k, v := range labels {
				if strVal, ok := v.(string); ok {
					newLabels[k] = strVal
				} else {
					// å¤„ç†ç©ºå€¼çš„æƒ…å†µ
					newLabels[k] = ""
				}
			}
		}
	}

	if newLabels == nil {
		newLabels = make(map[string]string)
	}

	fmt.Printf("ğŸ” DEBUG [UpdateNodeYAML]: New labels: %+v\n", newLabels)

	// æå–æ–°çš„ taints
	var newTaints []v1.Taint
	if spec, ok := yamlData["spec"].(map[string]interface{}); ok {
		if taintsData, ok := spec["taints"].([]interface{}); ok {
			newTaints = make([]v1.Taint, 0, len(taintsData))
			for _, taintItem := range taintsData {
				if taintMap, ok := taintItem.(map[string]interface{}); ok {
					taint := v1.Taint{}
					if key, ok := taintMap["key"].(string); ok {
						taint.Key = key
					}
					if value, ok := taintMap["value"].(string); ok {
						taint.Value = value
					}
					if effect, ok := taintMap["effect"].(string); ok {
						taint.Effect = v1.TaintEffect(effect)
					}
					newTaints = append(newTaints, taint)
				}
			}
		}
	}

	fmt.Printf("ğŸ” DEBUG [UpdateNodeYAML]: New taints: %+v\n", newTaints)

	// å…ˆè·å–å½“å‰èŠ‚ç‚¹
	node, err := clientset.CoreV1().Nodes().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		fmt.Printf("âŒ DEBUG [UpdateNodeYAML]: Get node failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	// å®Œå…¨æ›¿æ¢ labels
	node.Labels = newLabels

	// å®Œå…¨æ›¿æ¢ taints
	node.Spec.Taints = newTaints

	// ä½¿ç”¨ Update æ–¹æ³•æ›´æ–°èŠ‚ç‚¹ï¼ˆè¿™æ ·å¯ä»¥ç¡®ä¿ labels å’Œ taints è¢«å®Œå…¨æ›¿æ¢ï¼‰
	_, err = clientset.CoreV1().Nodes().Update(
		c.Request.Context(),
		node,
		metav1.UpdateOptions{},
	)
	if err != nil {
		fmt.Printf("âŒ DEBUG [UpdateNodeYAML]: Update failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "æ›´æ–°èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [UpdateNodeYAML]: Updated node %s successfully with %d labels and %d taints\n", nodeName, len(newLabels), len(newTaints))

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
	})
}

// DrainNodeRequest æ’ç©ºèŠ‚ç‚¹è¯·æ±‚
type DrainNodeRequest struct {
	ClusterID int `json:"clusterId" binding:"required"`
}

// DrainNode æ’ç©ºèŠ‚ç‚¹
func (h *ResourceHandler) DrainNode(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	var req DrainNodeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("ğŸ” DEBUG [DrainNode]: Starting drain for node %s\n", nodeName)

	// è·å–èŠ‚ç‚¹ä¸Šçš„æ‰€æœ‰Pod
	pods, err := clientset.CoreV1().Pods("").List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		fmt.Printf("âŒ DEBUG [DrainNode]: List pods failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–Podåˆ—è¡¨å¤±è´¥: " + err.Error(),
		})
		return
	}

	// é©±é€è¯¥èŠ‚ç‚¹ä¸Šçš„æ‰€æœ‰Podï¼ˆé™¤äº†DaemonSetçš„Podï¼‰
	evictedCount := 0
	for _, pod := range pods.Items {
		if pod.Spec.NodeName != nodeName {
			continue
		}

		// è·³è¿‡DaemonSetç®¡ç†çš„Pod
		if pod.OwnerReferences != nil {
			isDaemonSet := false
			for _, ownerRef := range pod.OwnerReferences {
				if ownerRef.Kind == "DaemonSet" {
					isDaemonSet = true
					break
				}
			}
			if isDaemonSet {
				fmt.Printf("â­ï¸  DEBUG [DrainNode]: Skipping DaemonSet pod %s\n", pod.Name)
				continue
			}
		}

		// é©±é€Pod
		err = clientset.CoreV1().Pods(pod.Namespace).EvictV1(context.Background(), &policyv1.Eviction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      pod.Name,
				Namespace: pod.Namespace,
			},
		})
		if err != nil {
			fmt.Printf("âš ï¸  DEBUG [DrainNode]: Failed to evict pod %s/%s: %v\n", pod.Namespace, pod.Name, err)
			// ç»§ç»­é©±é€å…¶ä»–Podï¼Œä¸ä¸­æ–­
			continue
		}
		evictedCount++
		fmt.Printf("âœ… DEBUG [DrainNode]: Evicted pod %s/%s\n", pod.Namespace, pod.Name)
	}

	fmt.Printf("âœ… DEBUG [DrainNode]: Drain completed for node %s, evicted %d pods\n", nodeName, evictedCount)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "èŠ‚ç‚¹æ’ç©ºæˆåŠŸ",
		"data": gin.H{
			"evictedPods": evictedCount,
		},
	})
}

// CordonNodeRequest è®¾ä¸ºä¸å¯è°ƒåº¦è¯·æ±‚
type CordonNodeRequest struct {
	ClusterID int `json:"clusterId" binding:"required"`
}

// CordonNode è®¾ä¸ºä¸å¯è°ƒåº¦
func (h *ResourceHandler) CordonNode(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	var req CordonNodeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–èŠ‚ç‚¹
	node, err := clientset.CoreV1().Nodes().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ä¸å¯è°ƒåº¦çŠ¶æ€
	if node.Spec.Unschedulable {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"message": "èŠ‚ç‚¹å·²ç»æ˜¯ä¸å¯è°ƒåº¦çŠ¶æ€",
		})
		return
	}

	// è®¾ä¸ºä¸å¯è°ƒåº¦
	node.Spec.Unschedulable = true
	_, err = clientset.CoreV1().Nodes().Update(c.Request.Context(), node, metav1.UpdateOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è®¾ä¸ºä¸å¯è°ƒåº¦å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "èŠ‚ç‚¹å·²è®¾ä¸ºä¸å¯è°ƒåº¦",
	})
}

// UncordonNode è®¾ä¸ºå¯è°ƒåº¦
func (h *ResourceHandler) UncordonNode(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	var req CordonNodeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–èŠ‚ç‚¹
	node, err := clientset.CoreV1().Nodes().Get(c.Request.Context(), nodeName, metav1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å¯è°ƒåº¦çŠ¶æ€
	if !node.Spec.Unschedulable {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"message": "èŠ‚ç‚¹å·²ç»æ˜¯å¯è°ƒåº¦çŠ¶æ€",
		})
		return
	}

	// è®¾ä¸ºå¯è°ƒåº¦
	node.Spec.Unschedulable = false
	_, err = clientset.CoreV1().Nodes().Update(c.Request.Context(), node, metav1.UpdateOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è®¾ä¸ºå¯è°ƒåº¦å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "èŠ‚ç‚¹å·²è®¾ä¸ºå¯è°ƒåº¦",
	})
}

// DeleteNode åˆ é™¤èŠ‚ç‚¹
func (h *ResourceHandler) DeleteNode(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	fmt.Printf("ğŸ” DEBUG [DeleteNode]: Deleting node %s, clusterID=%d\n", nodeName, clusterID)

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID.(uint))
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// åˆ é™¤èŠ‚ç‚¹
	err = clientset.CoreV1().Nodes().Delete(c.Request.Context(), nodeName, metav1.DeleteOptions{})
	if err != nil {
		fmt.Printf("âŒ DEBUG [DeleteNode]: Delete node failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åˆ é™¤èŠ‚ç‚¹å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… DEBUG [DeleteNode]: Node %s deleted successfully\n", nodeName)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "èŠ‚ç‚¹åˆ é™¤æˆåŠŸ",
	})
}

// yamlMarshal ç®€å•çš„YAMLåºåˆ—åŒ–
func yamlMarshal(obj interface{}) ([]byte, error) {
	return yaml.Marshal(obj)
}

// yamlUnmarshal ç®€å•çš„YAMLååºåˆ—åŒ–
func yamlUnmarshal(data []byte, obj interface{}) error {
	return yaml.Unmarshal(data, obj)
}

// cleanNodeForYAML æ¸…ç†Nodeå¯¹è±¡ç”¨äºYAMLè¾“å‡º
func cleanNodeForYAML(node *v1.Node) map[string]interface{} {
	// åˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œé¿å…ä¿®æ”¹åŸå§‹å¯¹è±¡
	cleaned := node.DeepCopy()

	// ç§»é™¤ managedFields
	if cleaned.ObjectMeta.ManagedFields != nil {
		cleaned.ObjectMeta.ManagedFields = nil
	}

	// è½¬æ¢ä¸º map ä»¥ä¾¿æ§åˆ¶ YAML åºåˆ—åŒ–é¡ºåº
	result := make(map[string]interface{})

	// ç¡®ä¿ apiVersion å’Œ kind åœ¨æœ€å‰é¢
	result["apiVersion"] = "v1"
	result["kind"] = "Node"

	// æ·»åŠ  metadata
	metadata := make(map[string]interface{})
	if cleaned.Name != "" {
		metadata["name"] = cleaned.Name
	}
	if len(cleaned.Labels) > 0 {
		metadata["labels"] = cleaned.Labels
	}
	if len(cleaned.Annotations) > 0 {
		metadata["annotations"] = cleaned.Annotations
	}
	// ä¸åŒ…å« resourceVersionï¼Œä½¿ç”¨ PATCH æ›´æ–°æ—¶ä¸éœ€è¦
	if len(cleaned.Finalizers) > 0 {
		metadata["finalizers"] = cleaned.Finalizers
	}

	result["metadata"] = metadata

	// æ·»åŠ  spec
	spec := make(map[string]interface{})
	if cleaned.Spec.PodCIDR != "" {
		spec["podCIDR"] = cleaned.Spec.PodCIDR
	}
	if len(cleaned.Spec.PodCIDRs) > 0 {
		spec["podCIDRs"] = cleaned.Spec.PodCIDRs
	}
	if cleaned.Spec.ProviderID != "" {
		spec["providerID"] = cleaned.Spec.ProviderID
	}
	if cleaned.Spec.Unschedulable {
		spec["unschedulable"] = cleaned.Spec.Unschedulable
	}
	if len(cleaned.Spec.Taints) > 0 {
		spec["taints"] = cleaned.Spec.Taints
	}
	if cleaned.Spec.ConfigSource != nil {
		spec["configSource"] = cleaned.Spec.ConfigSource
	}

	result["spec"] = spec

	// ä¸åŒ…å« statusï¼Œå› ä¸º status æ˜¯ç”± Kubernetes è‡ªåŠ¨ç®¡ç†çš„

	return result
}

// WebSocket upgrader
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true // å…è®¸æ‰€æœ‰æ¥æºï¼Œç”Ÿäº§ç¯å¢ƒåº”è¯¥æ›´ä¸¥æ ¼
	},
}

// NodeShell WebSocket å¤„ç†å™¨ - ä½¿ç”¨ debug pod æ–¹å¼
func (h *ResourceHandler) NodeShellWebSocket(c *gin.Context) {
	nodeName := c.Param("nodeName")
	if nodeName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "èŠ‚ç‚¹åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// å‡çº§åˆ° WebSocket è¿æ¥
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("WebSocket upgrade failed: %v", err)
		return
	}
	defer conn.Close()

	fmt.Printf("ğŸš WebSocket shell connected to node %s, clusterID=%d\n", nodeName, clusterID)

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID.(uint))
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// è·å– REST config
	restConfig, err := h.clusterService.GetRESTConfig(uint(clusterID), currentUserID.(uint))
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("è·å–é›†ç¾¤é…ç½®å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// åˆ›å»ºä¸´æ—¶ debug pod
	debugPodName := fmt.Sprintf("debug-%s-%d", nodeName, time.Now().Unix())
	debugNamespace := "default"

	conn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf("æ­£åœ¨åˆ›å»ºä¸´æ—¶ debug pod: %s...\r\n", debugPodName)))

	// å®šä¹‰ debug podï¼ˆä½¿ç”¨ node profile å…±äº«èŠ‚ç‚¹å‘½åç©ºé—´ï¼‰
	debugPod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      debugPodName,
			Namespace: debugNamespace,
			Labels: map[string]string{
				"app":        "opshub-debug",
				"node":       nodeName,
				"created-by": "opshub",
			},
		},
		Spec: v1.PodSpec{
			// ä½¿ç”¨èŠ‚ç‚¹äº²å’Œæ€§ç¡®ä¿è°ƒåº¦åˆ°ç›®æ ‡èŠ‚ç‚¹
			NodeName: nodeName,
			// ä½¿ç”¨ hostPID å’Œ hostNetwork å…±äº«èŠ‚ç‚¹çš„è¿›ç¨‹å’Œç½‘ç»œå‘½åç©ºé—´
			HostPID:       true,
			HostNetwork:   true,
			RestartPolicy: v1.RestartPolicyNever,
			// å®¹å™¨é…ç½®
			Containers: []v1.Container{
				{
					Name:    "debug",
					Image:   "swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nicolaka/netshoot:latest",
					Command: []string{"/bin/bash"},
					Args:    []string{"-c", "sleep 3600"}, // ä¿æŒè¿è¡Œ
					Stdin:   true,
					TTY:     true,
					// å®‰å…¨ä¸Šä¸‹æ–‡
					SecurityContext: &v1.SecurityContext{
						Privileged: func() *bool { b := true; return &b }(),
					},
				},
			},
			//å®¹å¿æ‰€æœ‰æ±¡ç‚¹ï¼Œç¡®ä¿å¯ä»¥è°ƒåº¦åˆ°ä»»ä½•èŠ‚ç‚¹
			Tolerations: []v1.Toleration{
				{
					Operator: v1.TolerationOpExists,
				},
			},
		},
	}

	// åˆ›å»º debug pod
	createdPod, err := clientset.CoreV1().Pods(debugNamespace).Create(c.Request.Context(), debugPod, metav1.CreateOptions{})
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("åˆ›å»º debug pod å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	fmt.Printf("ğŸš Created debug pod: %s/%s\n", debugNamespace, createdPod.Name)
	conn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf("Debug pod åˆ›å»ºæˆåŠŸï¼Œç­‰å¾…å¯åŠ¨...\r\n")))

	// ç­‰å¾… pod å¯åŠ¨ï¼ˆæœ€å¤šç­‰å¾…30ç§’ï¼‰
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	err = h.waitForPodReady(ctx, clientset, debugNamespace, debugPodName, conn)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("ç­‰å¾… debug pod å¯åŠ¨å¤±è´¥: "+err.Error()+"\r\n"))
		// æ¸…ç† pod
		clientset.CoreV1().Pods(debugNamespace).Delete(ctx, debugPodName, metav1.DeleteOptions{})
		return
	}

	conn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf("å·²è¿æ¥åˆ°èŠ‚ç‚¹ %s\r\n\r\n", nodeName)))

	// ç¡®ä¿åœ¨è¿æ¥å…³é—­æ—¶æ¸…ç† pod
	defer func() {
		fmt.Printf("ğŸš Cleaning up debug pod: %s/%s\n", debugNamespace, debugPodName)
		clientset.CoreV1().Pods(debugNamespace).Delete(context.Background(), debugPodName, metav1.DeleteOptions{})
	}()

	// æ„é€  exec URL
	serverURL, err := url.Parse(restConfig.Host)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("è§£æé›†ç¾¤ URL å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// æ„é€  query å‚æ•°
	query := url.Values{}
	query.Set("container", "debug")
	query.Set("stdin", "true")
	query.Set("stdout", "true")
	query.Set("stderr", "true")
	query.Set("tty", "true")

	// ä½¿ç”¨ nsenter è¿›å…¥èŠ‚ç‚¹æ ¹å‘½åç©ºé—´
	query.Add("command", "/bin/bash")
	query.Add("command", "-c")
	query.Add("command", "nsenter -t 1 -m -u -i -n -p -- /bin/bash || /bin/bash")

	execURL := &url.URL{
		Scheme:   serverURL.Scheme,
		Host:     serverURL.Host,
		Path:     fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", debugNamespace, debugPodName),
		RawQuery: query.Encode(),
	}

	fmt.Printf("ğŸš Exec URL: %s\n", execURL.String())

	// åˆ›å»º SPDY executor
	executor, err := remotecommand.NewSPDYExecutor(restConfig, "POST", execURL)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("åˆ›å»º executor å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// åˆ›å»º WebSocket è¯»å†™å™¨
	wsReader := &WebSocketReader{
		conn: conn,
		data: make(chan []byte, 256),
	}
	wsWriter := &WebSocketWriter{conn: conn}

	// å¤„ç† WebSocket æ¶ˆæ¯
	done := make(chan struct{})
	go func() {
		defer close(done)
		for {
			_, data, err := conn.ReadMessage()
			if err != nil {
				fmt.Printf("ğŸš WebSocket read error: %v\n", err)
				return
			}
			wsReader.data <- data
		}
	}()

	// å‘é€åˆå§‹æ¶ˆæ¯
	conn.WriteMessage(websocket.TextMessage, []byte("è¿æ¥æˆåŠŸï¼Œæ­£åœ¨åˆå§‹åŒ– shell...\r\n"))

	// å¯åŠ¨ exec ä¼šè¯ï¼Œä½¿ç”¨ chroot æˆ– nsenter è¿›å…¥èŠ‚ç‚¹ shell
	// æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å®¹å™¨æœ‰è¶³å¤Ÿæƒé™ï¼ˆç‰¹æƒå®¹å™¨ï¼‰ï¼Œé€šå¸¸ä½¿ç”¨ kube-system çš„ Pod
	streamOptions := remotecommand.StreamOptions{
		Stdin:  wsReader,
		Stdout: wsWriter,
		Stderr: wsWriter,
		Tty:    true,
	}

	// æ‰§è¡Œè¿œç¨‹å‘½ä»¤ï¼ˆå‘½ä»¤å·²åœ¨ URL query å‚æ•°ä¸­æŒ‡å®šï¼‰
	err = executor.Stream(streamOptions)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("Shell æ‰§è¡Œå¤±è´¥: "+err.Error()+"\r\n"))
		fmt.Printf("ğŸš Shell execution error: %v\n", err)
	}

	<-done
	fmt.Printf("ğŸš WebSocket shell disconnected from node %s\n", nodeName)
}

// WebSocketReader å®ç° io.Reader æ¥å£
type WebSocketReader struct {
	conn *websocket.Conn
	data chan []byte
}

func (r *WebSocketReader) Read(p []byte) (int, error) {
	data, ok := <-r.data
	if !ok {
		return 0, io.EOF
	}
	n := copy(p, data)
	return n, nil
}

// WebSocketWriter å®ç° io.Writer æ¥å£
type WebSocketWriter struct {
	conn *websocket.Conn
}

func (w *WebSocketWriter) Write(p []byte) (int, error) {
	err := w.conn.WriteMessage(websocket.TextMessage, p)
	if err != nil {
		return 0, err
	}
	return len(p), nil
}

// waitForPodReady ç­‰å¾… Pod å‡†å¤‡å°±ç»ª
func (h *ResourceHandler) waitForPodReady(ctx context.Context, clientset *kubernetes.Clientset, namespace, podName string, conn *websocket.Conn) error {
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			pod, err := clientset.CoreV1().Pods(namespace).Get(ctx, podName, metav1.GetOptions{})
			if err != nil {
				return fmt.Errorf("è·å– pod çŠ¶æ€å¤±è´¥: %w", err)
			}

			switch pod.Status.Phase {
			case v1.PodRunning:
				// æ£€æŸ¥å®¹å™¨æ˜¯å¦å°±ç»ª
				for _, cs := range pod.Status.ContainerStatuses {
					if !cs.Ready {
						// å®¹å™¨è¿˜æœªå°±ç»ªï¼Œç»§ç»­ç­‰å¾…
						goto continueWait
					}
				}
				fmt.Printf("ğŸš Pod %s/%s is ready\n", namespace, podName)
				return nil
			case v1.PodFailed, v1.PodSucceeded:
				return fmt.Errorf("pod %s/%s å¤„äº %s çŠ¶æ€", namespace, podName, pod.Status.Phase)
			}
		}
	continueWait:
	}
}

// GetCloudTTYStatus æ£€æŸ¥ CloudTTY æ˜¯å¦å·²å®‰è£…
func (h *ResourceHandler) GetCloudTTYStatus(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID.(uint))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    gin.H{"installed": false},
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// æ£€æŸ¥ CloudTTY deployment æ˜¯å¦å­˜åœ¨
	_, err = clientset.AppsV1().Deployments("cloudtty-system").Get(c.Request.Context(), "cloudtty-controller-manager", metav1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 0,
			"data": gin.H{"installed": false},
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code": 0,
		"data": gin.H{"installed": true},
	})
}

// DeployCloudTTY éƒ¨ç½² CloudTTY
func (h *ResourceHandler) DeployCloudTTY(c *gin.Context) {
	var req struct {
		ClusterID int `json:"clusterId" binding:"required"`
	}

	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‚æ•°é”™è¯¯",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// åˆ›å»º cloudtty-system å‘½åç©ºé—´
	ns := &v1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "cloudtty-system",
			Labels: map[string]string{
				"name": "cloudtty-system",
			},
		},
	}

	_, err = clientset.CoreV1().Namespaces().Create(c.Request.Context(), ns, metav1.CreateOptions{})
	if err != nil && !strings.Contains(err.Error(), "already exists") {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åˆ›å»ºå‘½åç©ºé—´å¤±è´¥: " + err.Error(),
		})
		return
	}

	// CloudTTY CRD å®šä¹‰ï¼ˆå¦‚æœéœ€è¦ï¼‰
	// æ³¨æ„ï¼šå®é™…éƒ¨ç½² CloudTTY éœ€è¦ä½¿ç”¨ kubectl apply æˆ–è€… helm
	// è¿™é‡Œæä¾›ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥ä½¿ç”¨ CloudTTY å®˜æ–¹å®‰è£…æ–¹å¼

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "CloudTTY éƒ¨ç½²åŠŸèƒ½éœ€è¦ä½¿ç”¨å®˜æ–¹ helm chart æˆ– kubectl manifest",
		"data": gin.H{
			"note": "è¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤éƒ¨ç½² CloudTTY:",
			"commands": []string{
				"helm repo add cloudtty https://cloudtty.github.io/cloudtty",
				"helm repo update",
				"helm install cloudtty cloudtty/cloudtty -n cloudtty-system --create-namespace",
			},
		},
	})
}

// GetCloudTTYService è·å– CloudTTY æœåŠ¡ä¿¡æ¯
func (h *ResourceHandler) GetCloudTTYService(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å– clientsetï¼ˆç”¨äºè·å–èŠ‚ç‚¹ä¿¡æ¯ï¼‰
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID.(uint))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–é›†ç¾¤çš„ kubeconfig ç”¨äº kubectl å‘½ä»¤
	kubeConfig, err := h.clusterService.GetClusterKubeConfig(c.Request.Context(), uint(clusterID))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤ kubeconfig å¤±è´¥",
		})
		return
	}

	// å°† kubeconfig å†™å…¥ä¸´æ—¶æ–‡ä»¶
	tmpFile, err := os.CreateTemp("", "kubeconfig-*.yaml")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åˆ›å»ºä¸´æ—¶æ–‡ä»¶å¤±è´¥",
		})
		return
	}
	defer os.Remove(tmpFile.Name())
	defer tmpFile.Close()

	if _, err := tmpFile.WriteString(kubeConfig); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "å†™å…¥ kubeconfig å¤±è´¥",
		})
		return
	}

	// ä½¿ç”¨ kubectl è·å– cloudshell CR
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, "kubectl", "get", "cloudshell", "-n", "cloudtty-system", "-o", "json")
	cmd.Env = append(os.Environ(), "KUBECONFIG="+tmpFile.Name())

	output, err := cmd.CombinedOutput()
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": fmt.Sprintf("CloudTTY cloudshellæœªæ‰¾åˆ°: %v, output: %s", err, string(output)),
		})
		return
	}

	// è§£æ JSON è¾“å‡º
	var result struct {
		Items []struct {
			Metadata struct {
				Name string `json:"name"`
			} `json:"metadata"`
			Status struct {
				AccessURL string `json:"accessURL"`
				Phase     string `json:"phase"`
			} `json:"status"`
		} `json:"items"`
	}

	if err := json.Unmarshal(output, &result); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": fmt.Sprintf("è§£æ cloudshell æ•°æ®å¤±è´¥: %v", err),
		})
		return
	}

	if len(result.Items) == 0 {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": "CloudTTY cloudshell å®ä¾‹æœªæ‰¾åˆ°",
		})
		return
	}

	// è·å–ç¬¬ä¸€ä¸ª cloudshell å®ä¾‹
	cloudshell := result.Items[0]

	// æ£€æŸ¥ cloudshell çŠ¶æ€æ˜¯å¦å°±ç»ªï¼ˆReady æˆ– Complete éƒ½è¡¨ç¤ºå¯ç”¨ï¼‰
	if cloudshell.Status.Phase != "Ready" && cloudshell.Status.Phase != "Complete" {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": fmt.Sprintf("CloudTTY cloudshell çŠ¶æ€æœªå°±ç»ª: %s", cloudshell.Status.Phase),
		})
		return
	}

	if cloudshell.Status.AccessURL == "" {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": "CloudTTY cloudshell AccessURL ä¸ºç©º",
		})
		return
	}

	// è§£æ AccessURL æå–ç«¯å£å·ï¼ˆæ ¼å¼: "IP:PORT"ï¼‰
	// æ³¨æ„ï¼šIP å¯èƒ½æ˜¯ Service ClusterIPï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨èŠ‚ç‚¹ IP
	accessURL := cloudshell.Status.AccessURL
	parts := strings.Split(accessURL, ":")
	if len(parts) != 2 {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": fmt.Sprintf("CloudTTY AccessURL æ ¼å¼é”™è¯¯: %s", accessURL),
		})
		return
	}

	nodePort := parts[1]

	// è·å–é›†ç¾¤èŠ‚ç‚¹åˆ—è¡¨ï¼Œé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹çš„ IP
	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹åˆ—è¡¨å¤±è´¥",
		})
		return
	}

	if len(nodes.Items) == 0 {
		c.JSON(http.StatusOK, gin.H{
			"code":    0,
			"data":    nil,
			"message": "é›†ç¾¤ä¸­æ²¡æœ‰å¯ç”¨èŠ‚ç‚¹",
		})
		return
	}

	// è·å–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„ IPï¼ˆä¼˜å…ˆä½¿ç”¨ InternalIPï¼‰
	var nodeIP string
	for _, addr := range nodes.Items[0].Status.Addresses {
		if addr.Type == v1.NodeInternalIP {
			nodeIP = addr.Address
			break
		}
	}

	if nodeIP == "" {
		// å¦‚æœæ²¡æœ‰ InternalIPï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªåœ°å€
		nodeIP = nodes.Items[0].Status.Addresses[0].Address
	}

	c.JSON(http.StatusOK, gin.H{
		"code": 0,
		"data": gin.H{
			"nodeIP":    nodeIP,
			"port":      nodePort,
			"type":      "NodePort",
			"path":      "/",
			"installed": true,
			"ready":     true,
		},
	})
}

// CreateCloudTTYService åˆ›å»º CloudTTY Service
func (h *ResourceHandler) CreateCloudTTYService(c *gin.Context) {
	var req struct {
		ClusterID int `json:"clusterId" binding:"required"`
	}

	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‚æ•°é”™è¯¯",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID.(uint))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–ä¸€ä¸ªèŠ‚ç‚¹IP
	nodes, err := clientset.CoreV1().Nodes().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil || len(nodes.Items) == 0 {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–èŠ‚ç‚¹åˆ—è¡¨å¤±è´¥",
		})
		return
	}
	nodeIP := nodes.Items[0].Status.Addresses[0].Address

	// åˆ›å»ºCloudTTY Service
	svc := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "cloudtty",
			Namespace: "cloudtty-system",
			Labels: map[string]string{
				"app": "cloudtty",
			},
		},
		Spec: v1.ServiceSpec{
			Type: v1.ServiceTypeNodePort,
			Ports: []v1.ServicePort{
				{
					Port:       80,
					TargetPort: intstr.IntOrString{IntVal: 30000},
					NodePort:   30000,
				},
			},
			Selector: map[string]string{
				"app": "cloudtty",
			},
		},
	}

	_, err = clientset.CoreV1().Services("cloudtty-system").Create(c.Request.Context(), svc, metav1.CreateOptions{})
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			c.JSON(http.StatusOK, gin.H{
				"code":    0,
				"message": "CloudTTY Serviceå·²å­˜åœ¨",
				"data": gin.H{
					"nodeIP": nodeIP,
					"port":   30000,
					"path":   "/cloudtty",
				},
			})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åˆ›å»ºServiceå¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… Created CloudTTY Service: %s:%d\n", nodeIP, 30000)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "CloudTTY Serviceåˆ›å»ºæˆåŠŸ",
		"data": gin.H{
			"nodeIP": nodeIP,
			"port":   30000,
			"path":   "/cloudtty",
		},
	})
}

// WorkloadInfo å·¥ä½œè´Ÿè½½ä¿¡æ¯
type WorkloadInfo struct {
	Name        string            `json:"name"`
	Namespace   string            `json:"namespace"`
	Type        string            `json:"type"`
	Labels      map[string]string `json:"labels"`
	ReadyPods   int32             `json:"readyPods"`
	DesiredPods int32             `json:"desiredPods"`
	Requests    *ResourceInfo     `json:"requests,omitempty"`
	Limits      *ResourceInfo     `json:"limits,omitempty"`
	Images      []string          `json:"images,omitempty"`
	CreatedAt   string            `json:"createdAt"`
	UpdatedAt   string            `json:"updatedAt"`
}

// ResourceInfo èµ„æºä¿¡æ¯
type ResourceInfo struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

// GetWorkloads è·å–å·¥ä½œè´Ÿè½½åˆ—è¡¨
func (h *ResourceHandler) GetWorkloads(c *gin.Context) {
	// è·å–å‚æ•°
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	workloadType := c.Query("type")   // Deployment, StatefulSet, DaemonSet, Job, CronJob
	namespace := c.Query("namespace") // å‘½åç©ºé—´è¿‡æ»¤

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	fmt.Printf("ğŸ“Š [GetWorkloads] ç”¨æˆ· %d æŸ¥è¯¢é›†ç¾¤ %d çš„å·¥ä½œè´Ÿè½½åˆ—è¡¨, ç±»å‹: %s, å‘½åç©ºé—´: %s\n",
		currentUserID, clusterID, workloadType, namespace)

	var workloads []WorkloadInfo
	ctx := c.Request.Context()

	// æ ¹æ®ç±»å‹æŸ¥è¯¢ä¸åŒçš„å·¥ä½œè´Ÿè½½
	if workloadType == "" || workloadType == "Deployment" {
		// è·å– Deployments
		deployments, err := clientset.AppsV1().Deployments(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, deploy := range deployments.Items {
				workload := h.convertDeploymentToWorkload(&deploy)
				workloads = append(workloads, workload)
			}
		}
	}

	if workloadType == "" || workloadType == "StatefulSet" {
		// è·å– StatefulSets
		stsList, err := clientset.AppsV1().StatefulSets(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, sts := range stsList.Items {
				workload := h.convertStatefulSetToWorkload(&sts)
				workloads = append(workloads, workload)
			}
		}
	}

	if workloadType == "" || workloadType == "DaemonSet" {
		// è·å– DaemonSets
		dsList, err := clientset.AppsV1().DaemonSets(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, ds := range dsList.Items {
				workload := h.convertDaemonSetToWorkload(&ds)
				workloads = append(workloads, workload)
			}
		}
	}

	if workloadType == "" || workloadType == "Job" {
		// è·å– Jobs
		jobList, err := clientset.BatchV1().Jobs(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, job := range jobList.Items {
				workload := h.convertJobToWorkload(&job)
				workloads = append(workloads, workload)
			}
		}
	}

	if workloadType == "" || workloadType == "CronJob" {
		// è·å– CronJobs
		cronJobList, err := clientset.BatchV1().CronJobs(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, cronJob := range cronJobList.Items {
				workload := h.convertCronJobToWorkload(&cronJob)
				workloads = append(workloads, workload)
			}
		}
	}

	if workloadType == "" || workloadType == "Pod" {
		// è·å– Pods
		podList, err := clientset.CoreV1().Pods(namespace).List(ctx, metav1.ListOptions{})
		if err == nil {
			for _, pod := range podList.Items {
				workload := h.convertPodToWorkload(&pod)
				workloads = append(workloads, workload)
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    workloads,
	})
}

// convertDeploymentToWorkload å°† Deployment è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertDeploymentToWorkload(deploy *appsv1.Deployment) WorkloadInfo {
	// è®¡ç®— Pod æ•°é‡
	readyPods := deploy.Status.ReadyReplicas
	desiredPods := int32(0)
	if deploy.Spec.Replicas != nil {
		desiredPods = *deploy.Spec.Replicas
	}

	// è·å–é•œåƒå’Œèµ„æºä¿¡æ¯
	var images []string
	var requests, limits *ResourceInfo

	if len(deploy.Spec.Template.Spec.Containers) > 0 {
		for _, container := range deploy.Spec.Template.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(deploy.Spec.Template.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        deploy.Name,
		Namespace:   deploy.Namespace,
		Type:        "Deployment",
		Labels:      deploy.Labels,
		ReadyPods:   readyPods,
		DesiredPods: desiredPods,
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   deploy.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   deploy.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// convertStatefulSetToWorkload å°† StatefulSet è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertStatefulSetToWorkload(sts *appsv1.StatefulSet) WorkloadInfo {
	readyPods := sts.Status.ReadyReplicas
	desiredPods := int32(0)
	if sts.Spec.Replicas != nil {
		desiredPods = *sts.Spec.Replicas
	}

	var images []string
	var requests, limits *ResourceInfo

	if len(sts.Spec.Template.Spec.Containers) > 0 {
		for _, container := range sts.Spec.Template.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(sts.Spec.Template.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        sts.Name,
		Namespace:   sts.Namespace,
		Type:        "StatefulSet",
		Labels:      sts.Labels,
		ReadyPods:   readyPods,
		DesiredPods: desiredPods,
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   sts.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   sts.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// convertDaemonSetToWorkload å°† DaemonSet è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertDaemonSetToWorkload(ds *appsv1.DaemonSet) WorkloadInfo {
	readyPods := ds.Status.NumberReady
	desiredPods := ds.Status.DesiredNumberScheduled

	var images []string
	var requests, limits *ResourceInfo

	if len(ds.Spec.Template.Spec.Containers) > 0 {
		for _, container := range ds.Spec.Template.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(ds.Spec.Template.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        ds.Name,
		Namespace:   ds.Namespace,
		Type:        "DaemonSet",
		Labels:      ds.Labels,
		ReadyPods:   readyPods,
		DesiredPods: desiredPods,
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   ds.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   ds.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// convertJobToWorkload å°† Job è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertJobToWorkload(job *batchv1.Job) WorkloadInfo {
	readyPods := job.Status.Succeeded
	desiredPods := *job.Spec.Parallelism

	var images []string
	var requests, limits *ResourceInfo

	if len(job.Spec.Template.Spec.Containers) > 0 {
		for _, container := range job.Spec.Template.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(job.Spec.Template.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        job.Name,
		Namespace:   job.Namespace,
		Type:        "Job",
		Labels:      job.Labels,
		ReadyPods:   readyPods,
		DesiredPods: desiredPods,
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   job.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   job.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// convertCronJobToWorkload å°† CronJob è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertCronJobToWorkload(cronJob *batchv1.CronJob) WorkloadInfo {
	var images []string
	var requests, limits *ResourceInfo

	if len(cronJob.Spec.JobTemplate.Spec.Template.Spec.Containers) > 0 {
		for _, container := range cronJob.Spec.JobTemplate.Spec.Template.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(cronJob.Spec.JobTemplate.Spec.Template.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        cronJob.Name,
		Namespace:   cronJob.Namespace,
		Type:        "CronJob",
		Labels:      cronJob.Labels,
		ReadyPods:   0,
		DesiredPods: 0,
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   cronJob.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   cronJob.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// convertPodToWorkload å°† Pod è½¬æ¢ä¸º WorkloadInfo
func (h *ResourceHandler) convertPodToWorkload(pod *v1.Pod) WorkloadInfo {
	// è®¡ç®— Pod å°±ç»ªçŠ¶æ€
	readyPods := int32(0)
	if pod.Status.Phase == "Running" {
		for _, cs := range pod.Status.ContainerStatuses {
			if cs.Ready {
				readyPods++
			}
		}
	}

	var images []string
	var requests, limits *ResourceInfo

	if len(pod.Spec.Containers) > 0 {
		for _, container := range pod.Spec.Containers {
			images = append(images, container.Image)
		}
		requests, limits = h.getResourceInfo(pod.Spec.Containers)
	}

	return WorkloadInfo{
		Name:        pod.Name,
		Namespace:   pod.Namespace,
		Type:        "Pod",
		Labels:      pod.Labels,
		ReadyPods:   readyPods,
		DesiredPods: 1, // Pod å§‹ç»ˆæœŸæœ› 1 ä¸ªå‰¯æœ¬ï¼ˆè‡ªèº«ï¼‰
		Requests:    requests,
		Limits:      limits,
		Images:      images,
		CreatedAt:   pod.CreationTimestamp.Format("2006-01-02 15:04:05"),
		UpdatedAt:   pod.CreationTimestamp.Format("2006-01-02 15:04:05"),
	}
}

// getResourceInfo è·å–å®¹å™¨çš„èµ„æºä¿¡æ¯
func (h *ResourceHandler) getResourceInfo(containers []v1.Container) (requests, limits *ResourceInfo) {
	var totalCPUReq, totalMemReq int64
	var totalCPULim, totalMemLim int64

	for _, container := range containers {
		if container.Resources.Requests != nil {
			totalCPUReq += container.Resources.Requests.Cpu().MilliValue()
			totalMemReq += container.Resources.Requests.Memory().Value()
		}
		if container.Resources.Limits != nil {
			totalCPULim += container.Resources.Limits.Cpu().MilliValue()
			totalMemLim += container.Resources.Limits.Memory().Value()
		}
	}

	if totalCPUReq > 0 || totalMemReq > 0 {
		requests = &ResourceInfo{
			CPU:    formatCPU(totalCPUReq),
			Memory: formatMemory(totalMemReq),
		}
	}

	if totalCPULim > 0 || totalMemLim > 0 {
		limits = &ResourceInfo{
			CPU:    formatCPU(totalCPULim),
			Memory: formatMemory(totalMemLim),
		}
	}

	return requests, limits
}

// formatCPU æ ¼å¼åŒ– CPU
func formatCPU(milliValue int64) string {
	if milliValue == 0 {
		return ""
	}
	if milliValue < 1000 {
		return fmt.Sprintf("%dm", milliValue)
	}
	return fmt.Sprintf("%.2f", float64(milliValue)/1000)
}

// formatMemory æ ¼å¼åŒ–å†…å­˜
func formatMemory(bytes int64) string {
	if bytes == 0 {
		return ""
	}

	const (
		KB = 1024
		MB = 1024 * KB
		GB = 1024 * MB
		TB = 1024 * GB
	)

	switch {
	case bytes >= TB:
		return fmt.Sprintf("%.2fTi", float64(bytes)/float64(TB))
	case bytes >= GB:
		return fmt.Sprintf("%.2fGi", float64(bytes)/float64(GB))
	case bytes >= MB:
		return fmt.Sprintf("%.2fMi", float64(bytes)/float64(MB))
	case bytes >= KB:
		return fmt.Sprintf("%.2fKi", float64(bytes)/float64(KB))
	default:
		return fmt.Sprintf("%d", bytes)
	}
}

// GetWorkloadYAMLRequest è·å–å·¥ä½œè´Ÿè½½YAMLè¯·æ±‚
type GetWorkloadYAMLRequest struct {
	ClusterID int    `form:"clusterId" binding:"required"`
	Type      string `form:"type" binding:"required"` // Deployment, StatefulSet, DaemonSet, Job, CronJob
}

// GetWorkloadYAML è·å–å·¥ä½œè´Ÿè½½YAML
func (h *ResourceHandler) GetWorkloadYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	// ä» query å‚æ•°è·å–é›†ç¾¤IDå’Œç±»å‹
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	workloadType := c.Query("type")
	if workloadType == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å·¥ä½œè´Ÿè½½ç±»å‹å‚æ•°",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	fmt.Printf("ğŸ” DEBUG [GetWorkloadYAML]: namespace=%s, name=%s, clusterID=%d, userID=%d, type=%s\n",
		namespace, name, clusterID, currentUserID, workloadType)

	// è·å–clientsetï¼ˆä¿®å¤å‚æ•°é¡ºåºï¼šclusterID åœ¨å‰ï¼ŒuserID åœ¨åï¼‰
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ ¹æ®ç±»å‹è·å–èµ„æº
	var obj interface{}
	switch workloadType {
	case "Deployment":
		deployment, err := clientset.AppsV1().Deployments(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å–Deploymentå¤±è´¥: " + err.Error(),
			})
			return
		}
		obj = deployment
	case "StatefulSet":
		statefulset, err := clientset.AppsV1().StatefulSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å–StatefulSetå¤±è´¥: " + err.Error(),
			})
			return
		}
		obj = statefulset
	case "DaemonSet":
		daemonset, err := clientset.AppsV1().DaemonSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å–DaemonSetå¤±è´¥: " + err.Error(),
			})
			return
		}
		obj = daemonset
	case "Job":
		job, err := clientset.BatchV1().Jobs(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å–Jobå¤±è´¥: " + err.Error(),
			})
			return
		}
		obj = job
	case "CronJob":
		cronjob, err := clientset.BatchV1().CronJobs(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å–CronJobå¤±è´¥: " + err.Error(),
			})
			return
		}
		obj = cronjob
	default:
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + workloadType,
		})
		return
	}

	// æ¸…ç†å¯¹è±¡ï¼ˆç§»é™¤ managedFields å’Œ status ç­‰ä¸éœ€è¦çš„å­—æ®µï¼‰
	cleanedObj := cleanWorkloadForYAML(obj, workloadType)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": cleanedObj,
		},
	})
}

// GetWorkloadDetail è·å–å·¥ä½œè´Ÿè½½è¯¦æƒ…
func (h *ResourceHandler) GetWorkloadDetail(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	workloadType := c.Query("type")
	if workloadType == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å·¥ä½œè´Ÿè½½ç±»å‹å‚æ•°",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	var workload interface{}
	switch workloadType {
	case "Deployment":
		deployment, err := clientset.AppsV1().Deployments(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "Deployment")
			return
		}
		workload = deployment
	case "StatefulSet":
		sts, err := clientset.AppsV1().StatefulSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "StatefulSet")
			return
		}
		workload = sts
	case "DaemonSet":
		ds, err := clientset.AppsV1().DaemonSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "DaemonSet")
			return
		}
		workload = ds
	case "Job":
		job, err := clientset.BatchV1().Jobs(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "Job")
			return
		}
		workload = job
	case "CronJob":
		cronjob, err := clientset.BatchV1().CronJobs(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "CronJob")
			return
		}
		workload = cronjob
	default:
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": []interface{}{workload},
		},
	})
}

// GetWorkloadReplicaSets è·å–å·¥ä½œè´Ÿè½½çš„ReplicaSetåˆ—è¡¨
func (h *ResourceHandler) GetWorkloadReplicaSets(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–è¯¥å·¥ä½œè´Ÿè½½çš„æ‰€æœ‰ReplicaSet
	labelSelector := fmt.Sprintf("app=%s", name)
	replicaSets, err := clientset.AppsV1().ReplicaSets(namespace).List(c.Request.Context(), metav1.ListOptions{
		LabelSelector: labelSelector,
	})
	if err != nil {
		HandleK8sError(c, err, "ReplicaSet")
		return
	}

	// è½¬æ¢ä¸ºé€šç”¨æ ¼å¼
	var items []interface{}
	for _, rs := range replicaSets.Items {
		items = append(items, rs)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": items,
		},
	})
}

// GetWorkloadPods è·å–å·¥ä½œè´Ÿè½½çš„Podåˆ—è¡¨
func (h *ResourceHandler) GetWorkloadPods(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	workloadType := c.Query("type")

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–å·¥ä½œè´Ÿè½½çš„æ ‡ç­¾é€‰æ‹©å™¨
	var labelSelector string

	switch workloadType {
	case "Deployment":
		deployment, err := clientset.AppsV1().Deployments(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "Deployment")
			return
		}
		// æ„å»º label selector
		var selectors []string
		for k, v := range deployment.Spec.Selector.MatchLabels {
			selectors = append(selectors, fmt.Sprintf("%s=%s", k, v))
		}
		labelSelector = strings.Join(selectors, ",")

	case "StatefulSet":
		sts, err := clientset.AppsV1().StatefulSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "StatefulSet")
			return
		}
		var selectors []string
		for k, v := range sts.Spec.Selector.MatchLabels {
			selectors = append(selectors, fmt.Sprintf("%s=%s", k, v))
		}
		labelSelector = strings.Join(selectors, ",")

	case "DaemonSet":
		ds, err := clientset.AppsV1().DaemonSets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
		if err != nil {
			HandleK8sError(c, err, "DaemonSet")
			return
		}
		var selectors []string
		for k, v := range ds.Spec.Selector.MatchLabels {
			selectors = append(selectors, fmt.Sprintf("%s=%s", k, v))
		}
		labelSelector = strings.Join(selectors, ",")

	default:
		// é»˜è®¤ä½¿ç”¨ app=<name>
		labelSelector = fmt.Sprintf("app=%s", name)
	}

	// è·å–è¯¥å·¥ä½œè´Ÿè½½çš„æ‰€æœ‰Pod
	pods, err := clientset.CoreV1().Pods(namespace).List(c.Request.Context(), metav1.ListOptions{
		LabelSelector: labelSelector,
	})
	if err != nil {
		HandleK8sError(c, err, "Pod")
		return
	}

	// è½¬æ¢ä¸ºé€šç”¨æ ¼å¼
	var items []interface{}
	for _, pod := range pods.Items {
		items = append(items, pod)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": items,
		},
	})
}

// GetWorkloadServices è·å–å·¥ä½œè´Ÿè½½å…³è”çš„Serviceåˆ—è¡¨
func (h *ResourceHandler) GetWorkloadServices(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–æ‰€æœ‰Service
	services, err := clientset.CoreV1().Services(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Service")
		return
	}

	// è¿‡æ»¤å‡ºä¸è¯¥å·¥ä½œè´Ÿè½½å…³è”çš„Serviceï¼ˆé€šè¿‡selectoråŒ¹é…ï¼‰
	var items []interface{}
	for _, svc := range services.Items {
		if svc.Spec.Selector != nil {
			if appName, exists := svc.Spec.Selector["app"]; exists && appName == name {
				items = append(items, svc)
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": items,
		},
	})
}

// GetWorkloadIngresses è·å–å·¥ä½œè´Ÿè½½å…³è”çš„Ingressåˆ—è¡¨
func (h *ResourceHandler) GetWorkloadIngresses(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥",
		})
		return
	}

	// è·å–æ‰€æœ‰Ingress
	ingresses, err := clientset.NetworkingV1().Ingresses(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	// è¿‡æ»¤å‡ºä¸è¯¥å·¥ä½œè´Ÿè½½å…³è”çš„Ingressï¼ˆé€šè¿‡service.nameåŒ¹é…ï¼‰
	var items []interface{}
	for _, ing := range ingresses.Items {
		for _, rule := range ing.Spec.Rules {
			if rule.HTTP != nil {
				for _, path := range rule.HTTP.Paths {
					serviceName := path.Backend.Service.Name
					if serviceName == name {
						items = append(items, ing)
						break
					}
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": items,
		},
	})
}

// UpdateWorkloadYAMLRequest æ›´æ–°å·¥ä½œè´Ÿè½½YAMLè¯·æ±‚
type UpdateWorkloadYAMLRequest struct {
	ClusterID int    `json:"clusterId" binding:"required"`
	Type      string `json:"type" binding:"required"`
	YAML      string `json:"yaml" binding:"required"`
}

// UpdateWorkloadYAML æ›´æ–°å·¥ä½œè´Ÿè½½YAML
func (h *ResourceHandler) UpdateWorkloadYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	var req UpdateWorkloadYAMLRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	fmt.Printf("ğŸ” DEBUG [UpdateWorkloadYAML]: namespace=%s, name=%s, clusterID=%d, userID=%d, type=%s\n",
		namespace, name, req.ClusterID, currentUserID, req.Type)

	// è·å–clientsetï¼ˆä¿®å¤å‚æ•°é¡ºåºï¼šclusterID åœ¨å‰ï¼ŒuserID åœ¨åï¼‰
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è§£æYAML
	var yamlData map[string]interface{}
	if err := yamlUnmarshal([]byte(req.YAML), &yamlData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æYAMLå¤±è´¥: " + err.Error(),
		})
		return
	}

	// éªŒè¯èµ„æºåç§°
	if metadata, ok := yamlData["metadata"].(map[string]interface{}); ok {
		if yamlName, ok := metadata["name"].(string); ok && yamlName != name {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "YAMLä¸­çš„èµ„æºåç§°ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
		if yamlNamespace, ok := metadata["namespace"].(string); ok && yamlNamespace != namespace {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "YAMLä¸­çš„å‘½åç©ºé—´ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
	}

	// è½¬æ¢ä¸ºJSONç”¨äºPATCH
	patchData, err := json.Marshal(yamlData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–Patchæ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ ¹æ®ç±»å‹æ›´æ–°èµ„æº
	switch req.Type {
	case "Deployment":
		_, err := clientset.AppsV1().Deployments(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°Deploymentå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "StatefulSet":
		_, err := clientset.AppsV1().StatefulSets(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°StatefulSetå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "DaemonSet":
		_, err := clientset.AppsV1().DaemonSets(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°DaemonSetå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "Job":
		_, err := clientset.BatchV1().Jobs(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°Jobå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "CronJob":
		_, err := clientset.BatchV1().CronJobs(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°CronJobå¤±è´¥: " + err.Error(),
			})
			return
		}
	default:
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + req.Type,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true, // å‘Šè¯‰å‰ç«¯éœ€è¦åˆ·æ–°åˆ—è¡¨
		},
	})
}

// UpdateWorkloadRequest æ›´æ–°å·¥ä½œè´Ÿè½½è¯·æ±‚ï¼ˆæ‰€æœ‰å‚æ•°åœ¨è¯·æ±‚ä½“ä¸­ï¼‰
// UpdateWorkloadRequest ç›´æ¥æ¥æ”¶ Kubernetes å¯¹è±¡
// ä» URL å‚æ•°è·å– clusterã€namespaceã€typeã€nameï¼Œè¯·æ±‚ä½“ç›´æ¥æ˜¯ Kubernetes å¯¹è±¡
type UpdateWorkloadRequest struct {
	// è¿™äº›å­—æ®µä» URL å‚æ•°è·å–ï¼Œä¸åœ¨è¯·æ±‚ä½“ä¸­
	Cluster  string
	Namespace string
	Type     string
	Name     string
	// WorkloadData æ˜¯è¯·æ±‚ä½“ï¼Œç›´æ¥æ˜¯ Kubernetes å¯¹è±¡
	WorkloadData map[string]interface{}
}

// UpdateWorkload æ›´æ–°å·¥ä½œè´Ÿè½½
// URL å‚æ•°: cluster, namespace, type, name
// è¯·æ±‚ä½“: ç›´æ¥æ˜¯ Kubernetes å¯¹è±¡ï¼ˆDeploymentã€StatefulSet ç­‰ï¼‰
func (h *ResourceHandler) UpdateWorkload(c *gin.Context) {
	// ä» URL å‚æ•°è·å–åŸºæœ¬ä¿¡æ¯
	cluster := c.Query("cluster")
	namespace := c.Query("namespace")
	workloadType := c.Query("type")
	name := c.Query("name")

	if cluster == "" || namespace == "" || workloadType == "" || name == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å¿…è¦å‚æ•°: cluster, namespace, type, name",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	fmt.Printf("ğŸ” DEBUG [UpdateWorkload]: cluster=%s, namespace=%s, name=%s, type=%s, userID=%d\n",
		cluster, namespace, name, workloadType, currentUserID)

	// æ ¹æ®é›†ç¾¤åç§°è·å–é›†ç¾¤IDï¼ˆæŸ¥è¯¢æ•°æ®åº“ï¼‰
	var clusterID int
	err := h.db.Raw("SELECT id FROM k8s_clusters WHERE name = ? AND created_by = ? LIMIT 1", cluster, currentUserID).Scan(&clusterID).Error
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤ä¿¡æ¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ç›´æ¥ä»è¯·æ±‚ä½“è¯»å– Kubernetes å¯¹è±¡
	var yamlData map[string]interface{}
	if err := c.ShouldBindJSON(&yamlData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æè¯·æ±‚ä½“å¤±è´¥: " + err.Error(),
		})
		return
	}

	// éªŒè¯èµ„æºåç§°
	if metadata, ok := yamlData["metadata"].(map[string]interface{}); ok {
		if yamlName, ok := metadata["name"].(string); ok && yamlName != name {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "YAMLä¸­çš„èµ„æºåç§°ä¸URLå‚æ•°ä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
		if yamlNamespace, ok := metadata["namespace"].(string); ok && yamlNamespace != namespace {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "YAMLä¸­çš„å‘½åç©ºé—´ä¸è¯·æ±‚ä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
	}

	// è½¬æ¢ä¸ºJSONç”¨äºPATCH
	patchData, err := json.Marshal(yamlData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–Patchæ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ ¹æ®ç±»å‹æ›´æ–°èµ„æº
	switch workloadType {
	case "Deployment":
		_, err := clientset.AppsV1().Deployments(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°Deploymentå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "StatefulSet":
		_, err := clientset.AppsV1().StatefulSets(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°StatefulSetå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "DaemonSet":
		_, err := clientset.AppsV1().DaemonSets(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°DaemonSetå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "Job":
		_, err := clientset.BatchV1().Jobs(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°Jobå¤±è´¥: " + err.Error(),
			})
			return
		}
	case "CronJob":
		_, err := clientset.BatchV1().CronJobs(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–°CronJobå¤±è´¥: " + err.Error(),
			})
			return
		}
	default:
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + workloadType,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true, // å‘Šè¯‰å‰ç«¯éœ€è¦åˆ·æ–°åˆ—è¡¨
		},
	})
}

// CreateWorkloadFromYAML ä» YAML åˆ›å»ºå·¥ä½œè´Ÿè½½
func (h *ResourceHandler) CreateWorkloadFromYAML(c *gin.Context) {
	var req struct {
		ClusterID uint   `json:"clusterId" binding:"required"`
		YAML      string `json:"yaml" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "å‚æ•°é”™è¯¯: " + err.Error()})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	fmt.Printf("ğŸ¯ CreateWorkloadFromYAML: clusterID=%d, userID=%d\n", req.ClusterID, currentUserID)

	// è§£æ YAML
	yamlDecoder := k8syaml.NewYAMLOrJSONDecoder(strings.NewReader(req.YAML), 4096)
	var yamlObj map[string]interface{}
	if err := yamlDecoder.Decode(&yamlObj); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ YAML å¤±è´¥: " + err.Error()})
		return
	}

	// è·å–èµ„æºç±»å‹å’Œå…ƒæ•°æ®
	kind, _ := yamlObj["kind"].(string)
	metadata, _ := yamlObj["metadata"].(map[string]interface{})
	namespace, _ := metadata["namespace"].(string)
	name, _ := metadata["name"].(string)

	if kind == "" || name == "" {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "YAML ç¼ºå°‘å¿…è¦å­—æ®µ kind æˆ– metadata.name"})
		return
	}

	// é»˜è®¤å‘½åç©ºé—´ä¸º default
	if namespace == "" {
		namespace = "default"
		metadata["namespace"] = namespace
	}

	// è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), req.ClusterID, currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error()})
		return
	}

	// è½¬æ¢ä¸º JSON
	jsonData, err := json.Marshal(yamlObj)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error()})
		return
	}

	// æ ¹æ®ç±»å‹åˆ›å»ºèµ„æº
	switch kind {
	case "Deployment":
		var deployment appsv1.Deployment
		if err := json.Unmarshal(jsonData, &deployment); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ Deployment å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.AppsV1().Deployments(namespace).Create(c.Request.Context(), &deployment, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º Deployment å¤±è´¥: " + err.Error()})
			return
		}

	case "StatefulSet":
		var sts appsv1.StatefulSet
		if err := json.Unmarshal(jsonData, &sts); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ StatefulSet å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.AppsV1().StatefulSets(namespace).Create(c.Request.Context(), &sts, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º StatefulSet å¤±è´¥: " + err.Error()})
			return
		}

	case "DaemonSet":
		var ds appsv1.DaemonSet
		if err := json.Unmarshal(jsonData, &ds); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ DaemonSet å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.AppsV1().DaemonSets(namespace).Create(c.Request.Context(), &ds, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º DaemonSet å¤±è´¥: " + err.Error()})
			return
		}

	case "Job":
		var job batchv1.Job
		if err := json.Unmarshal(jsonData, &job); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ Job å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.BatchV1().Jobs(namespace).Create(c.Request.Context(), &job, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º Job å¤±è´¥: " + err.Error()})
			return
		}

	case "CronJob":
		var cronJob batchv1.CronJob
		if err := json.Unmarshal(jsonData, &cronJob); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ CronJob å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.BatchV1().CronJobs(namespace).Create(c.Request.Context(), &cronJob, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º CronJob å¤±è´¥: " + err.Error()})
			return
		}

	case "Pod":
		var pod v1.Pod
		if err := json.Unmarshal(jsonData, &pod); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è§£æ Pod å¤±è´¥: " + err.Error()})
			return
		}
		_, err = clientset.CoreV1().Pods(namespace).Create(c.Request.Context(), &pod, metav1.CreateOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "åˆ›å»º Pod å¤±è´¥: " + err.Error()})
			return
		}

	default:
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + kind})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ›å»ºæˆåŠŸ",
		"data": gin.H{
			"kind":      kind,
			"namespace": namespace,
			"name":      name,
		},
	})
}

// DeleteWorkload åˆ é™¤å·¥ä½œè´Ÿè½½
func (h *ResourceHandler) DeleteWorkload(c *gin.Context) {
	// ä»URLå‚æ•°è·å–åŸºæœ¬ä¿¡æ¯
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterID := c.Query("clusterId")
	workloadType := c.Query("type")

	if namespace == "" || name == "" || clusterID == "" || workloadType == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å¿…è¦å‚æ•°: namespace, name, clusterId, type",
		})
		return
	}

	// è½¬æ¢clusterID
	clusterIDUint, err := strconv.ParseUint(clusterID, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„clusterId",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	fmt.Printf("ğŸ—‘ï¸ DeleteWorkload: namespace=%s, name=%s, type=%s, clusterID=%s, userID=%d\n",
		namespace, name, workloadType, clusterID, currentUserID)

	// è·å–clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterIDUint), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ ¹æ®ç±»å‹åˆ é™¤èµ„æº
	switch workloadType {
	case "Deployment":
		err = clientset.AppsV1().Deployments(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤Deploymentå¤±è´¥: " + err.Error(),
			})
			return
		}

	case "StatefulSet":
		err = clientset.AppsV1().StatefulSets(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤StatefulSetå¤±è´¥: " + err.Error(),
			})
			return
		}

	case "DaemonSet":
		err = clientset.AppsV1().DaemonSets(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤DaemonSetå¤±è´¥: " + err.Error(),
			})
			return
		}

	case "Job":
		err = clientset.BatchV1().Jobs(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤Jobå¤±è´¥: " + err.Error(),
			})
			return
		}

	case "CronJob":
		err = clientset.BatchV1().CronJobs(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤CronJobå¤±è´¥: " + err.Error(),
			})
			return
		}

	case "Pod":
		err = clientset.CoreV1().Pods(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "åˆ é™¤Podå¤±è´¥: " + err.Error(),
			})
			return
		}

	default:
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + workloadType,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"namespace": namespace,
			"name":      name,
			"type":      workloadType,
		},
	})
}

// cleanWorkloadForYAML æ¸…ç†å·¥ä½œè´Ÿè½½å¯¹è±¡ç”¨äºYAMLè¾“å‡º
func cleanWorkloadForYAML(obj interface{}, workloadType string) map[string]interface{} {
	// è½¬æ¢ä¸º map ä»¥ä¾¿æ§åˆ¶ YAML åºåˆ—åŒ–
	result := make(map[string]interface{})

	// æ ¹æ®ä¸åŒçš„å·¥ä½œè´Ÿè½½ç±»å‹è®¾ç½® apiVersion å’Œ kind
	switch workloadType {
	case "Deployment":
		result["apiVersion"] = "apps/v1"
		result["kind"] = "Deployment"
		if deploy, ok := obj.(*appsv1.Deployment); ok {
			result["metadata"] = cleanMetadata(deploy.ObjectMeta)
			result["spec"] = deploy.Spec
		}
	case "StatefulSet":
		result["apiVersion"] = "apps/v1"
		result["kind"] = "StatefulSet"
		if sts, ok := obj.(*appsv1.StatefulSet); ok {
			result["metadata"] = cleanMetadata(sts.ObjectMeta)
			result["spec"] = sts.Spec
		}
	case "DaemonSet":
		result["apiVersion"] = "apps/v1"
		result["kind"] = "DaemonSet"
		if ds, ok := obj.(*appsv1.DaemonSet); ok {
			result["metadata"] = cleanMetadata(ds.ObjectMeta)
			result["spec"] = ds.Spec
		}
	case "Job":
		result["apiVersion"] = "batch/v1"
		result["kind"] = "Job"
		if job, ok := obj.(*batchv1.Job); ok {
			result["metadata"] = cleanMetadata(job.ObjectMeta)
			result["spec"] = job.Spec
		}
	case "CronJob":
		result["apiVersion"] = "batch/v1"
		result["kind"] = "CronJob"
		if cronJob, ok := obj.(*batchv1.CronJob); ok {
			result["metadata"] = cleanMetadata(cronJob.ObjectMeta)
			result["spec"] = cronJob.Spec
		}
	}

	// ä¸åŒ…å« status å­—æ®µ

	return result
}

// cleanMetadata æ¸…ç† metadata å­—æ®µ
func cleanMetadata(meta metav1.ObjectMeta) map[string]interface{} {
	metadata := make(map[string]interface{})

	if meta.Name != "" {
		metadata["name"] = meta.Name
	}
	if meta.Namespace != "" {
		metadata["namespace"] = meta.Namespace
	}
	if len(meta.Labels) > 0 {
		metadata["labels"] = meta.Labels
	}
	if len(meta.Annotations) > 0 {
		metadata["annotations"] = meta.Annotations
	}
	// ä¸åŒ…å« managedFieldsã€resourceVersionã€uidã€generation ç­‰å­—æ®µ

	return metadata
}

// ==================== Service ç›¸å…³ ====================

// ServiceInfo æœåŠ¡ä¿¡æ¯
type ServiceInfo struct {
	Name            string            `json:"name"`            // æœåŠ¡åç§°
	Namespace       string            `json:"namespace"`       // å‘½åç©ºé—´
	Type            string            `json:"type"`            // æœåŠ¡ç±»å‹: ClusterIP, NodePort, LoadBalancer, ExternalName
	ClusterIP       string            `json:"clusterIP"`       // Cluster IP åœ°å€
	ExternalIP      string            `json:"externalIP"`      // External IP åœ°å€
	Ports           []ServicePortInfo `json:"ports"`           // ç«¯å£åˆ—è¡¨
	Selector        map[string]string `json:"selector"`        // Pod é€‰æ‹©å™¨
	SessionAffinity string            `json:"sessionAffinity"` // ä¼šè¯äº²å’Œæ€§
	Age             string            `json:"age"`             // åˆ›å»ºæ—¶é—´
	Labels          map[string]string `json:"labels"`          // æ ‡ç­¾
	Endpoints       int               `json:"endpoints"`       // ç«¯ç‚¹æ•°é‡
}

// ServicePortInfo æœåŠ¡ç«¯å£ä¿¡æ¯
type ServicePortInfo struct {
	Name       string `json:"name"`       // ç«¯å£åç§°
	Protocol   string `json:"protocol"`   // åè®®: TCP, UDP, SCTP
	Port       int32  `json:"port"`       // æœåŠ¡ç«¯å£
	TargetPort string `json:"targetPort"` // ç›®æ ‡ç«¯å£
	NodePort   int32  `json:"nodePort"`   // NodePort (ä»… NodePort ç±»å‹)
}

// ListServices è·å–æœåŠ¡åˆ—è¡¨
func (h *ResourceHandler) ListServices(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	services, err := clientset.CoreV1().Services(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	// è·å– Endpoints ç”¨äºç»Ÿè®¡ç«¯ç‚¹æ•°é‡
	endpointsMap := make(map[string]int)
	endpoints, err := clientset.CoreV1().Endpoints(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err == nil {
		for _, ep := range endpoints.Items {
			readyCount := 0
			for _, subset := range ep.Subsets {
				readyCount += len(subset.Addresses)
			}
			endpointsMap[ep.Name] = readyCount
		}
	}

	serviceInfos := make([]ServiceInfo, 0, len(services.Items))
	for _, svc := range services.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := svc.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		// ç¡®ä¿ selector ä¸ä¸º nil
		selector := svc.Spec.Selector
		if selector == nil {
			selector = make(map[string]string)
		}

		// è·å– External IP
		externalIP := ""
		if len(svc.Spec.ExternalIPs) > 0 {
			externalIP = svc.Spec.ExternalIPs[0]
		} else if svc.Spec.Type == v1.ServiceTypeLoadBalancer && len(svc.Status.LoadBalancer.Ingress) > 0 {
			if svc.Status.LoadBalancer.Ingress[0].IP != "" {
				externalIP = svc.Status.LoadBalancer.Ingress[0].IP
			} else if svc.Status.LoadBalancer.Ingress[0].Hostname != "" {
				externalIP = svc.Status.LoadBalancer.Ingress[0].Hostname
			}
		}

		// è½¬æ¢ç«¯å£ä¿¡æ¯
		portInfos := make([]ServicePortInfo, 0, len(svc.Spec.Ports))
		for _, port := range svc.Spec.Ports {
			targetPort := ""
			if port.TargetPort.Type == intstr.Int {
				targetPort = strconv.Itoa(int(port.TargetPort.IntVal))
			} else {
				targetPort = port.TargetPort.StrVal
			}

			portInfo := ServicePortInfo{
				Name:       port.Name,
				Protocol:   string(port.Protocol),
				Port:       port.Port,
				TargetPort: targetPort,
				NodePort:   port.NodePort,
			}
			portInfos = append(portInfos, portInfo)
		}

		serviceInfo := ServiceInfo{
			Name:            svc.Name,
			Namespace:       svc.Namespace,
			Type:            string(svc.Spec.Type),
			ClusterIP:       svc.Spec.ClusterIP,
			ExternalIP:      externalIP,
			Ports:           portInfos,
			Selector:        selector,
			SessionAffinity: string(svc.Spec.SessionAffinity),
			Age:             calculateAge(svc.CreationTimestamp.Time),
			Labels:          labels,
			Endpoints:       endpointsMap[svc.Name],
		}

		serviceInfos = append(serviceInfos, serviceInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    serviceInfos,
	})
}

// GetServiceYAML è·å–æœåŠ¡ YAML
func (h *ResourceHandler) GetServiceYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	svc, err := clientset.CoreV1().Services(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	// æ¸…ç†å¯¹è±¡ç”¨äº YAML è¾“å‡º
	cleanedSvc := cleanServiceForYAML(svc)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": cleanedSvc,
		},
	})
}

// UpdateServiceYAMLRequest æ›´æ–°æœåŠ¡ YAML è¯·æ±‚
// UpdateServiceYAMLRequest æ›´æ–°æœåŠ¡è¯·æ±‚
type UpdateServiceYAMLRequest struct {
	ClusterID int                    `json:"clusterId" binding:"required"`
	Data      map[string]interface{} `json:"-" binding:"required"`
}

// UpdateServiceYAML æ›´æ–°æœåŠ¡ YAML
func (h *ResourceHandler) UpdateServiceYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	// ç›´æ¥ç»‘å®šè¯·æ±‚ä½“åˆ° map[string]interface{}
	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// æå– clusterId
	clusterIDFloat, ok := jsonData["clusterId"].(float64)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘ clusterId å­—æ®µ",
		})
		return
	}
	clusterID := int(clusterIDFloat)

	// åˆ é™¤ clusterId å­—æ®µï¼Œå‰©ä½™çš„å°±æ˜¯ Kubernetes èµ„æºæ•°æ®
	delete(jsonData, "clusterId")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–ç°æœ‰ Service ä»¥ä¿ç•™èµ„æºç‰ˆæœ¬ç­‰ä¿¡æ¯
	existingSvc, err := clientset.CoreV1().Services(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	// å°† jsonData è½¬æ¢ä¸º Service å¯¹è±¡
	var service v1.Service
	serviceData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = json.Unmarshal(serviceData, &service)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è§£æ Service æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ä¿ç•™èµ„æºç‰ˆæœ¬ï¼Œç¡®ä¿æ›´æ–°æˆåŠŸ
	service.ResourceVersion = existingSvc.ResourceVersion

	// ä½¿ç”¨ Update è€Œä¸æ˜¯ Patchï¼Œè¿™æ ·å¯ä»¥å®Œå…¨æ›¿æ¢èµ„æºåŒ…æ‹¬åˆ é™¤æ•°ç»„å…ƒç´ 
	_, err = clientset.CoreV1().Services(namespace).Update(c.Request.Context(), &service, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// CreateServiceRequest åˆ›å»ºæœåŠ¡è¯·æ±‚
type CreateServiceRequest struct {
	ClusterID int                      `json:"clusterId" binding:"required"`
	Namespace string                   `json:"namespace" binding:"required"`
	Name      string                   `json:"name" binding:"required"`
	Type      string                   `json:"type" binding:"required"`
	ClusterIP string                   `json:"clusterIP"`
	Ports     []ServicePortCreateInfo  `json:"ports" binding:"required"`
	Selector  map[string]string        `json:"selector"`
	SessionAffinity string             `json:"sessionAffinity"`
}

// ServicePortCreateInfo ç«¯å£åˆ›å»ºä¿¡æ¯
type ServicePortCreateInfo struct {
	Name       string `json:"name"`
	Protocol   string `json:"protocol" binding:"required"`
	Port       int32  `json:"port" binding:"required"`
	TargetPort string `json:"targetPort"`
	NodePort   int32  `json:"nodePort"`
}

// CreateService åˆ›å»ºæœåŠ¡
func (h *ResourceHandler) CreateService(c *gin.Context) {
	namespace := c.Param("namespace")

	var req CreateServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ„å»º Service å¯¹è±¡
	svc := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      req.Name,
			Namespace: namespace,
		},
		Spec: v1.ServiceSpec{
			Type:            v1.ServiceType(req.Type),
			ClusterIP:       req.ClusterIP,
			Selector:        req.Selector,
			SessionAffinity: v1.ServiceAffinity(req.SessionAffinity),
		},
	}

	// å¦‚æœ ClusterIP ä¸º "None"ï¼Œè®¾ç½®ä¸º Headless Service
	if req.Type == "ClusterIP" && req.ClusterIP == "None" {
		svc.Spec.ClusterIP = "None"
	}

	// è½¬æ¢ç«¯å£ä¿¡æ¯
	for _, port := range req.Ports {
		servicePort := v1.ServicePort{
			Name:     port.Name,
			Protocol: v1.Protocol(port.Protocol),
			Port:     port.Port,
		}

		// è§£æ TargetPort
		if port.TargetPort != "" {
			// å°è¯•è§£æä¸ºæ•°å­—
			if portNum, err := strconv.Atoi(port.TargetPort); err == nil {
				servicePort.TargetPort = intstr.FromInt(portNum)
			} else {
				servicePort.TargetPort = intstr.FromString(port.TargetPort)
			}
		} else {
			// é»˜è®¤ä½¿ç”¨ Port
			servicePort.TargetPort = intstr.FromInt(int(port.Port))
		}

		// NodePort åªæœ‰ NodePort ç±»å‹æ‰éœ€è¦è®¾ç½®
	 if req.Type == "NodePort" && port.NodePort > 0 {
			servicePort.NodePort = port.NodePort
		}

		svc.Spec.Ports = append(svc.Spec.Ports, servicePort)
	}

	// åˆ›å»º Service
	_, err = clientset.CoreV1().Services(namespace).Create(c.Request.Context(), svc, metav1.CreateOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ›å»ºæˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteServiceRequest åˆ é™¤æœåŠ¡è¯·æ±‚
type DeleteServiceRequest struct {
	ClusterID int `json:"clusterId" binding:"required"`
}

// DeleteService åˆ é™¤æœåŠ¡
func (h *ResourceHandler) DeleteService(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	var req DeleteServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().Services(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "æœåŠ¡")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// cleanServiceForYAML æ¸…ç† Service å¯¹è±¡ç”¨äº YAML è¾“å‡º
func cleanServiceForYAML(svc *v1.Service) map[string]interface{} {
	result := make(map[string]interface{})
	result["apiVersion"] = "v1"
	result["kind"] = "Service"
	result["metadata"] = cleanMetadata(svc.ObjectMeta)
	result["spec"] = svc.Spec
	return result
}

// ==================== Ingress ç›¸å…³ ====================

// IngressInfo Ingress ä¿¡æ¯
type IngressInfo struct {
	Name         string            `json:"name"`         // Ingress åç§°
	Namespace    string            `json:"namespace"`    // å‘½åç©ºé—´
	Hosts        []string          `json:"hosts"`        // ä¸»æœºååˆ—è¡¨
	Paths        []IngressPathInfo `json:"paths"`        // è·¯å¾„åˆ—è¡¨
	TLS          []IngressTLSInfo  `json:"tls"`          // TLS é…ç½®
	IngressClass string            `json:"ingressClass"` // Ingress Class
	Age          string            `json:"age"`          // åˆ›å»ºæ—¶é—´
	Labels       map[string]string `json:"labels"`       // æ ‡ç­¾
	Addresses    []string          `json:"addresses"`    // IP åœ°å€åˆ—è¡¨
}

// IngressPathInfo Ingress è·¯å¾„ä¿¡æ¯
type IngressPathInfo struct {
	Host    string `json:"host"`    // ä¸»æœºå
	Path    string `json:"path"`    // è·¯å¾„
	PathType string `json:"pathType"` // è·¯å¾„ç±»å‹
	Service string `json:"service"` // æœåŠ¡åç§°
	Port    int32  `json:"port"`    // æœåŠ¡ç«¯å£
}

// IngressTLSInfo TLS é…ç½®
type IngressTLSInfo struct {
	Hosts      []string `json:"hosts"`      // ä¸»æœºååˆ—è¡¨
	SecretName string   `json:"secretName"` // Secret åç§°
}

// ListIngresses è·å– Ingress åˆ—è¡¨
func (h *ResourceHandler) ListIngresses(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å– Ingressï¼ˆä½¿ç”¨ networking.k8s.io/v1ï¼‰
	ingresses, err := clientset.NetworkingV1().Ingresses(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	ingressInfos := make([]IngressInfo, 0, len(ingresses.Items))
	for _, ing := range ingresses.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := ing.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		// è·å–ä¸»æœºååˆ—è¡¨
		hosts := make([]string, 0)
		for _, rule := range ing.Spec.Rules {
			if rule.Host != "" {
				hosts = append(hosts, rule.Host)
			}
		}

		// è·å–è·¯å¾„ä¿¡æ¯
		paths := make([]IngressPathInfo, 0)
		for _, rule := range ing.Spec.Rules {
			if rule.HTTP != nil {
				for _, path := range rule.HTTP.Paths {
					serviceName := ""
					servicePort := int32(0)
					if path.Backend.Service != nil {
						serviceName = path.Backend.Service.Name
						if path.Backend.Service.Port.Number > 0 {
							servicePort = path.Backend.Service.Port.Number
						}
					}

					pathInfo := IngressPathInfo{
						Host:     rule.Host,
						Path:     path.Path,
						PathType: string(*path.PathType),
						Service:  serviceName,
						Port:     servicePort,
					}
					paths = append(paths, pathInfo)
				}
			}
		}

		// è·å– TLS é…ç½®
		tlsInfos := make([]IngressTLSInfo, 0, len(ing.Spec.TLS))
		for _, tls := range ing.Spec.TLS {
			tlsInfo := IngressTLSInfo{
				Hosts:      tls.Hosts,
				SecretName: tls.SecretName,
			}
			tlsInfos = append(tlsInfos, tlsInfo)
		}

		// è·å– IngressClass
		ingressClass := ""
		if ing.Spec.IngressClassName != nil {
			ingressClass = *ing.Spec.IngressClassName
		}

		// è·å–åœ°å€
		addresses := make([]string, 0)
		for _, addr := range ing.Status.LoadBalancer.Ingress {
			if addr.IP != "" {
				addresses = append(addresses, addr.IP)
			} else if addr.Hostname != "" {
				addresses = append(addresses, addr.Hostname)
			}
		}

		ingressInfo := IngressInfo{
			Name:         ing.Name,
			Namespace:    ing.Namespace,
			Hosts:        hosts,
			Paths:        paths,
			TLS:          tlsInfos,
			IngressClass: ingressClass,
			Age:          calculateAge(ing.CreationTimestamp.Time),
			Labels:       labels,
			Addresses:    addresses,
		}

		ingressInfos = append(ingressInfos, ingressInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    ingressInfos,
	})
}

// GetIngressYAML è·å– Ingress YAML
func (h *ResourceHandler) GetIngressYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	ing, err := clientset.NetworkingV1().Ingresses(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	// æ¸…ç†å¯¹è±¡ç”¨äº YAML è¾“å‡º
	cleanedIngs := cleanIngressForYAML(ing)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": cleanedIngs,
		},
	})
}

// UpdateIngressYAML æ›´æ–° Ingress YAML
func (h *ResourceHandler) UpdateIngressYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	// ç›´æ¥ç»‘å®šè¯·æ±‚ä½“åˆ° map[string]interface{}
	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// æå– clusterId
	clusterIDFloat, ok := jsonData["clusterId"].(float64)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘ clusterId å­—æ®µ",
		})
		return
	}
	clusterID := int(clusterIDFloat)

	// åˆ é™¤ clusterId å­—æ®µï¼Œå‰©ä½™çš„å°±æ˜¯ Kubernetes èµ„æºæ•°æ®
	delete(jsonData, "clusterId")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// éªŒè¯èµ„æºåç§°
	if metadata, ok := jsonData["metadata"].(map[string]interface{}); ok {
		if jsonName, ok := metadata["name"].(string); ok && jsonName != name {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "èµ„æºåç§°ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
		if jsonNamespace, ok := metadata["namespace"].(string); ok && jsonNamespace != namespace {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "å‘½åç©ºé—´ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
	}

	// è½¬æ¢ä¸º JSON ç”¨äº PATCH
	patchData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–Patchæ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	_, err = clientset.NetworkingV1().Ingresses(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// CreateIngressRequest åˆ›å»º Ingress è¯·æ±‚
type CreateIngressRequest struct {
	ClusterID     int                   `json:"clusterId" binding:"required"`
	Namespace     string                `json:"namespace" binding:"required"`
	Name          string                `json:"name" binding:"required"`
	IngressClass  string                `json:"ingressClass"`
	Rules         []IngressRuleCreate   `json:"rules" binding:"required"`
	TLS           []IngressTLSCreate    `json:"tls"`
}

// IngressRuleCreate Ingress è§„åˆ™åˆ›å»ºä¿¡æ¯
type IngressRuleCreate struct {
	Host  string                 `json:"host"`
	Paths []IngressPathCreate    `json:"paths" binding:"required"`
}

// IngressPathCreate Ingress è·¯å¾„åˆ›å»ºä¿¡æ¯
type IngressPathCreate struct {
	Path     string `json:"path" binding:"required"`
	PathType string `json:"pathType" binding:"required"`
	Service  string `json:"service" binding:"required"`
	Port     int32  `json:"port" binding:"required"`
}

// IngressTLSCreate TLS åˆ›å»ºä¿¡æ¯
type IngressTLSCreate struct {
	Hosts      []string `json:"hosts"`
	SecretName string   `json:"secretName"`
}

// CreateIngress åˆ›å»º Ingress
func (h *ResourceHandler) CreateIngress(c *gin.Context) {
	namespace := c.Param("namespace")

	var req CreateIngressRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ„å»º Ingress å¯¹è±¡
	ing := &networkingv1.Ingress{
		ObjectMeta: metav1.ObjectMeta{
			Name:      req.Name,
			Namespace: namespace,
		},
	}

	// è®¾ç½® IngressClass
	if req.IngressClass != "" {
		ing.Spec.IngressClassName = &req.IngressClass
	}

	// è½¬æ¢è§„åˆ™
	for _, rule := range req.Rules {
		ingressRule := networkingv1.IngressRule{
			Host: rule.Host,
		}

		if len(rule.Paths) > 0 {
			httpRule := &networkingv1.HTTPIngressRuleValue{
				Paths: make([]networkingv1.HTTPIngressPath, 0, len(rule.Paths)),
			}

			for _, path := range rule.Paths {
				pathType := networkingv1.PathType(path.PathType)
				ingressPath := networkingv1.HTTPIngressPath{
					Path:     path.Path,
					PathType: &pathType,
					Backend: networkingv1.IngressBackend{
						Service: &networkingv1.IngressServiceBackend{
							Name: path.Service,
							Port: networkingv1.ServiceBackendPort{
								Number: path.Port,
							},
						},
					},
				}
				httpRule.Paths = append(httpRule.Paths, ingressPath)
			}

			ingressRule.HTTP = httpRule
		}

		ing.Spec.Rules = append(ing.Spec.Rules, ingressRule)
	}

	// è½¬æ¢ TLS
	for _, tls := range req.TLS {
		ingressTLS := networkingv1.IngressTLS{
			Hosts:      tls.Hosts,
			SecretName: tls.SecretName,
		}
		ing.Spec.TLS = append(ing.Spec.TLS, ingressTLS)
	}

	// åˆ›å»º Ingress
	_, err = clientset.NetworkingV1().Ingresses(namespace).Create(c.Request.Context(), ing, metav1.CreateOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ›å»ºæˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteIngress åˆ é™¤ Ingress
func (h *ResourceHandler) DeleteIngress(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	var req DeleteServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.NetworkingV1().Ingresses(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "Ingress")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// cleanIngressForYAML æ¸…ç† Ingress å¯¹è±¡ç”¨äº YAML è¾“å‡º
func cleanIngressForYAML(ing *networkingv1.Ingress) map[string]interface{} {
	result := make(map[string]interface{})
	result["apiVersion"] = "networking.k8s.io/v1"
	result["kind"] = "Ingress"
	result["metadata"] = cleanMetadata(ing.ObjectMeta)
	result["spec"] = ing.Spec
	return result
}

// ==================== Endpoints ç›¸å…³ ====================

// EndpointsInfo ç«¯ç‚¹ä¿¡æ¯
type EndpointsInfo struct {
	Name      string                `json:"name"`      // ç«¯ç‚¹åç§°ï¼ˆä¸ Service åŒåï¼‰
	Namespace string                `json:"namespace"` // å‘½åç©ºé—´
	Subsets   []EndpointSubsetInfo  `json:"subsets"`   // ç«¯ç‚¹å­é›†
	Age       string                `json:"age"`       // åˆ›å»ºæ—¶é—´
	Labels    map[string]string     `json:"labels"`    // æ ‡ç­¾
}

// EndpointSubsetInfo ç«¯ç‚¹å­é›†ä¿¡æ¯
type EndpointSubsetInfo struct {
	Addresses    []EndpointAddressInfo `json:"addresses"`    // åœ°å€åˆ—è¡¨
	NotReadyAddresses []EndpointAddressInfo `json:"notReadyAddresses"` // æœªå°±ç»ªåœ°å€
	Ports        []EndpointPortInfo    `json:"ports"`        // ç«¯å£åˆ—è¡¨
}

// EndpointAddressInfo ç«¯ç‚¹åœ°å€ä¿¡æ¯
type EndpointAddressInfo struct {
	IP        string `json:"ip"`        // IP åœ°å€
	Hostname  string `json:"hostname"`  // ä¸»æœºå
	NodeName  string `json:"nodeName"`  // èŠ‚ç‚¹åç§°
	TargetRef string `json:"targetRef"` // å…³è”çš„ Pod åç§°
	Ready     bool   `json:"ready"`     // æ˜¯å¦å°±ç»ª
}

// EndpointPortInfo ç«¯ç‚¹ç«¯å£ä¿¡æ¯
type EndpointPortInfo struct {
	Name     string `json:"name"`     // ç«¯å£åç§°
	Protocol string `json:"protocol"` // åè®®
	Port     int32  `json:"port"`     // ç«¯å£å·
}

// ListEndpoints è·å–ç«¯ç‚¹åˆ—è¡¨
func (h *ResourceHandler) ListEndpoints(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	endpoints, err := clientset.CoreV1().Endpoints(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç«¯ç‚¹")
		return
	}

	endpointsInfos := make([]EndpointsInfo, 0, len(endpoints.Items))
	for _, ep := range endpoints.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := ep.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		// è½¬æ¢å­é›†ä¿¡æ¯
		subsets := make([]EndpointSubsetInfo, 0, len(ep.Subsets))
		for _, subset := range ep.Subsets {
			subsetInfo := EndpointSubsetInfo{
				Addresses:    make([]EndpointAddressInfo, 0, len(subset.Addresses)),
				NotReadyAddresses: make([]EndpointAddressInfo, 0, len(subset.NotReadyAddresses)),
				Ports:        make([]EndpointPortInfo, 0, len(subset.Ports)),
			}

			// è½¬æ¢å°±ç»ªåœ°å€
			for _, addr := range subset.Addresses {
				nodeName := ""
				if addr.NodeName != nil {
					nodeName = *addr.NodeName
				}
				addrInfo := EndpointAddressInfo{
					IP:       addr.IP,
					Hostname: addr.Hostname,
					NodeName: nodeName,
					Ready:    true,
				}
				if addr.TargetRef != nil {
					addrInfo.TargetRef = addr.TargetRef.Name
				}
				subsetInfo.Addresses = append(subsetInfo.Addresses, addrInfo)
			}

			// è½¬æ¢æœªå°±ç»ªåœ°å€
			for _, addr := range subset.NotReadyAddresses {
				nodeName := ""
				if addr.NodeName != nil {
					nodeName = *addr.NodeName
				}
				addrInfo := EndpointAddressInfo{
					IP:       addr.IP,
					Hostname: addr.Hostname,
					NodeName: nodeName,
					Ready:    false,
				}
				if addr.TargetRef != nil {
					addrInfo.TargetRef = addr.TargetRef.Name
				}
				subsetInfo.NotReadyAddresses = append(subsetInfo.NotReadyAddresses, addrInfo)
			}

			// è½¬æ¢ç«¯å£
			for _, port := range subset.Ports {
				portInfo := EndpointPortInfo{
					Name:     port.Name,
					Protocol: string(port.Protocol),
					Port:     port.Port,
				}
				subsetInfo.Ports = append(subsetInfo.Ports, portInfo)
			}

			subsets = append(subsets, subsetInfo)
		}

		endpointsInfo := EndpointsInfo{
			Name:      ep.Name,
			Namespace: ep.Namespace,
			Subsets:   subsets,
			Age:       calculateAge(ep.CreationTimestamp.Time),
			Labels:    labels,
		}

		endpointsInfos = append(endpointsInfos, endpointsInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    endpointsInfos,
	})
}

// GetEndpointsDetail è·å–ç«¯ç‚¹è¯¦æƒ…
func (h *ResourceHandler) GetEndpointsDetail(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	ep, err := clientset.CoreV1().Endpoints(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç«¯ç‚¹")
		return
	}

	// è½¬æ¢ä¸ºå‰ç«¯æ ¼å¼
	// (å¤ç”¨ ListEndpoints ä¸­çš„è½¬æ¢é€»è¾‘)
	// ...

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    ep,
	})
}

// ==================== NetworkPolicy ç›¸å…³ ====================

// NetworkPolicyDetailInfo ç½‘ç»œç­–ç•¥è¯¦æƒ…
type NetworkPolicyDetailInfo struct {
	Name        string              `json:"name"`        // ç­–ç•¥åç§°
	Namespace   string              `json:"namespace"`   // å‘½åç©ºé—´
	PodSelector map[string]string   `json:"podSelector"` // Pod é€‰æ‹©å™¨
	Ingress     []PolicyRuleInfo    `json:"ingress"`     // å…¥ç«™è§„åˆ™
	Egress      []PolicyRuleInfo    `json:"egress"`      // å‡ºç«™è§„åˆ™
	Age         string              `json:"age"`         // åˆ›å»ºæ—¶é—´
	Labels      map[string]string   `json:"labels"`      // æ ‡ç­¾
}

// PolicyRuleInfo ç­–ç•¥è§„åˆ™
type PolicyRuleInfo struct {
	Ports []PolicyPortInfo `json:"ports"` // ç«¯å£
	From  []PolicyPeerInfo `json:"from"`  // æ¥æº (å…¥ç«™)
	To    []PolicyPeerInfo `json:"to"`    // ç›®æ ‡ (å‡ºç«™)
}

// PolicyPortInfo ç­–ç•¥ç«¯å£
type PolicyPortInfo struct {
	Protocol string `json:"protocol"` // åè®®
	Port     string `json:"port"`     // ç«¯å£å·/èŒƒå›´
}

// PolicyPeerInfo ç­–ç•¥å¯¹ç«¯
type PolicyPeerInfo struct {
	PodSelector       map[string]string `json:"podSelector"`       // Pod é€‰æ‹©å™¨
	NamespaceSelector map[string]string `json:"namespaceSelector"` // å‘½åç©ºé—´é€‰æ‹©å™¨
	IPBlock           *IPBlockInfo       `json:"ipBlock"`           // IP å—
}

// IPBlockInfo IP å—
type IPBlockInfo struct {
	CIDR   string   `json:"cidr"`   // CIDR è¡¨ç¤º
	Except []string `json:"except"` // æ’é™¤çš„ IP
}

// ListNetworkPolicies è·å–ç½‘ç»œç­–ç•¥åˆ—è¡¨
func (h *ResourceHandler) ListNetworkPolicies(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	policies, err := clientset.NetworkingV1().NetworkPolicies(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç½‘ç»œç­–ç•¥")
		return
	}

	policyInfos := make([]NetworkPolicyDetailInfo, 0, len(policies.Items))
	for _, np := range policies.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := np.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		// è½¬æ¢ Pod é€‰æ‹©å™¨
		podSelector := make(map[string]string)
		if np.Spec.PodSelector.MatchLabels != nil {
			podSelector = np.Spec.PodSelector.MatchLabels
		}

		// è½¬æ¢å…¥ç«™è§„åˆ™
		ingressRules := make([]PolicyRuleInfo, 0, len(np.Spec.Ingress))
		for _, rule := range np.Spec.Ingress {
			ruleInfo := PolicyRuleInfo{}

			// è½¬æ¢ç«¯å£
			for _, port := range rule.Ports {
				portInfo := PolicyPortInfo{}
				if port.Protocol != nil {
					portInfo.Protocol = string(*port.Protocol)
				}
				if port.Port != nil {
					if port.Port.Type == intstr.Int {
						portInfo.Port = strconv.Itoa(int(port.Port.IntVal))
					} else {
						portInfo.Port = port.Port.StrVal
					}
				}
				ruleInfo.Ports = append(ruleInfo.Ports, portInfo)
			}

			// è½¬æ¢æ¥æº
			for _, from := range rule.From {
				peerInfo := PolicyPeerInfo{}
				if from.PodSelector != nil {
					peerInfo.PodSelector = from.PodSelector.MatchLabels
				}
				if from.NamespaceSelector != nil {
					peerInfo.NamespaceSelector = from.NamespaceSelector.MatchLabels
				}
				if from.IPBlock != nil {
					peerInfo.IPBlock = &IPBlockInfo{
						CIDR:   from.IPBlock.CIDR,
						Except: from.IPBlock.Except,
					}
				}
				ruleInfo.From = append(ruleInfo.From, peerInfo)
			}

			ingressRules = append(ingressRules, ruleInfo)
		}

		// è½¬æ¢å‡ºç«™è§„åˆ™
		egressRules := make([]PolicyRuleInfo, 0, len(np.Spec.Egress))
		for _, rule := range np.Spec.Egress {
			ruleInfo := PolicyRuleInfo{}

			// è½¬æ¢ç«¯å£
			for _, port := range rule.Ports {
				portInfo := PolicyPortInfo{}
				if port.Protocol != nil {
					portInfo.Protocol = string(*port.Protocol)
				}
				if port.Port != nil {
					if port.Port.Type == intstr.Int {
						portInfo.Port = strconv.Itoa(int(port.Port.IntVal))
					} else {
						portInfo.Port = port.Port.StrVal
					}
				}
				ruleInfo.Ports = append(ruleInfo.Ports, portInfo)
			}

			// è½¬æ¢ç›®æ ‡
			for _, to := range rule.To {
				peerInfo := PolicyPeerInfo{}
				if to.PodSelector != nil {
					peerInfo.PodSelector = to.PodSelector.MatchLabels
				}
				if to.NamespaceSelector != nil {
					peerInfo.NamespaceSelector = to.NamespaceSelector.MatchLabels
				}
				if to.IPBlock != nil {
					peerInfo.IPBlock = &IPBlockInfo{
						CIDR:   to.IPBlock.CIDR,
						Except: to.IPBlock.Except,
					}
				}
				ruleInfo.To = append(ruleInfo.To, peerInfo)
			}

			egressRules = append(egressRules, ruleInfo)
		}

		policyInfo := NetworkPolicyDetailInfo{
			Name:        np.Name,
			Namespace:   np.Namespace,
			PodSelector: podSelector,
			Ingress:     ingressRules,
			Egress:      egressRules,
			Age:         calculateAge(np.CreationTimestamp.Time),
			Labels:      labels,
		}

		policyInfos = append(policyInfos, policyInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    policyInfos,
	})
}

// GetNetworkPolicyYAML è·å–ç½‘ç»œç­–ç•¥ YAML
func (h *ResourceHandler) GetNetworkPolicyYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	np, err := clientset.NetworkingV1().NetworkPolicies(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç½‘ç»œç­–ç•¥")
		return
	}

	// æ¸…ç†å¯¹è±¡ç”¨äº YAML è¾“å‡º
	cleanedNp := cleanNetworkPolicyForYAML(np)

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"items": cleanedNp,
		},
	})
}

// UpdateNetworkPolicyYAML æ›´æ–°ç½‘ç»œç­–ç•¥ YAML
func (h *ResourceHandler) UpdateNetworkPolicyYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	// ç›´æ¥ç»‘å®šè¯·æ±‚ä½“åˆ° map[string]interface{}
	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// æå– clusterId
	clusterIDFloat, ok := jsonData["clusterId"].(float64)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘ clusterId å­—æ®µ",
		})
		return
	}
	clusterID := int(clusterIDFloat)

	// åˆ é™¤ clusterId å­—æ®µï¼Œå‰©ä½™çš„å°±æ˜¯ Kubernetes èµ„æºæ•°æ®
	delete(jsonData, "clusterId")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// éªŒè¯èµ„æºåç§°
	if metadata, ok := jsonData["metadata"].(map[string]interface{}); ok {
		if jsonName, ok := metadata["name"].(string); ok && jsonName != name {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "èµ„æºåç§°ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
		if jsonNamespace, ok := metadata["namespace"].(string); ok && jsonNamespace != namespace {
			c.JSON(http.StatusBadRequest, gin.H{
				"code":    400,
				"message": "å‘½åç©ºé—´ä¸URLä¸­çš„ä¸ä¸€è‡´",
			})
			return
		}
	}

	// è½¬æ¢ä¸º JSON ç”¨äº PATCH
	patchData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–Patchæ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	_, err = clientset.NetworkingV1().NetworkPolicies(namespace).Patch(c.Request.Context(), name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç½‘ç»œç­–ç•¥")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteNetworkPolicy åˆ é™¤ç½‘ç»œç­–ç•¥
func (h *ResourceHandler) DeleteNetworkPolicy(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")

	var req DeleteServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.NetworkingV1().NetworkPolicies(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "ç½‘ç»œç­–ç•¥")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// cleanNetworkPolicyForYAML æ¸…ç† NetworkPolicy å¯¹è±¡ç”¨äº YAML è¾“å‡º
func cleanNetworkPolicyForYAML(np *networkingv1.NetworkPolicy) map[string]interface{} {
	result := make(map[string]interface{})
	result["apiVersion"] = "networking.k8s.io/v1"
	result["kind"] = "NetworkPolicy"
	result["metadata"] = cleanMetadata(np.ObjectMeta)
	result["spec"] = np.Spec
	return result
}
// CreateNamespaceRequest åˆ›å»ºå‘½åç©ºé—´è¯·æ±‚
type CreateNamespaceRequest struct {
	YAML string `json:"yaml" binding:"required"`
}

// UpdateNamespaceYAMLRequest æ›´æ–°å‘½åç©ºé—´YAMLè¯·æ±‚
type UpdateNamespaceYAMLRequest struct {
	ClusterID int    `json:"clusterId" binding:"required"`
	YAML      string `json:"yaml" binding:"required"`
}


// CreateNamespace åˆ›å»ºå‘½åç©ºé—´
func (h *ResourceHandler) CreateNamespace(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	var req CreateNamespaceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// è§£æ YAML
	var namespace v1.Namespace
	if err := yaml.Unmarshal([]byte(req.YAML), &namespace); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æ YAML å¤±è´¥: " + err.Error(),
		})
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// åˆ›å»ºå‘½åç©ºé—´
	_, err = clientset.CoreV1().Namespaces().Create(c.Request.Context(), &namespace, metav1.CreateOptions{})
	if err != nil {
		HandleK8sError(c, err, "å‘½åç©ºé—´")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ›å»ºæˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// GetNamespaceYAML è·å–å‘½åç©ºé—´YAML
func (h *ResourceHandler) GetNamespaceYAML(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespaceName := c.Param("namespaceName")
	if namespaceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‘½åç©ºé—´åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	namespace, err := clientset.CoreV1().Namespaces().Get(c.Request.Context(), namespaceName, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "å‘½åç©ºé—´")
		return
	}

	// æ¸…ç†å¯¹è±¡ç”¨äº YAML è¾“å‡º
	cleaned := cleanNamespaceForYAML(namespace)
	yamlBytes, err := yaml.Marshal(cleaned)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ– YAML å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"yaml": string(yamlBytes),
		},
	})
}

// UpdateNamespaceYAML æ›´æ–°å‘½åç©ºé—´YAML
func (h *ResourceHandler) UpdateNamespaceYAML(c *gin.Context) {
	namespaceName := c.Param("namespaceName")
	if namespaceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‘½åç©ºé—´åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	var req UpdateNamespaceYAMLRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è§£æ YAML
	var namespace v1.Namespace
	if err := yaml.Unmarshal([]byte(req.YAML), &namespace); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æ YAML å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ç¡®ä¿åç§°ä¸€è‡´
	namespace.Name = namespaceName

	// æ›´æ–°å‘½åç©ºé—´
	_, err = clientset.CoreV1().Namespaces().Update(c.Request.Context(), &namespace, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "å‘½åç©ºé—´")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteNamespace åˆ é™¤å‘½åç©ºé—´
func (h *ResourceHandler) DeleteNamespace(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespaceName := c.Param("namespaceName")
	if namespaceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‘½åç©ºé—´åç§°ä¸èƒ½ä¸ºç©º",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().Namespaces().Delete(c.Request.Context(), namespaceName, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "å‘½åç©ºé—´")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// cleanNamespaceForYAML æ¸…ç† Namespace å¯¹è±¡ç”¨äº YAML è¾“å‡º
func cleanNamespaceForYAML(ns *v1.Namespace) map[string]interface{} {
	result := make(map[string]interface{})
	result["apiVersion"] = "v1"
	result["kind"] = "Namespace"
	result["metadata"] = cleanMetadata(ns.ObjectMeta)
	return result
}

// ==================== ConfigMap ç›¸å…³ ====================

// ConfigMapInfo ConfigMap ä¿¡æ¯
type ConfigMapInfo struct {
	Name       string            `json:"name"`       // ConfigMap åç§°
	Namespace  string            `json:"namespace"`  // å‘½åç©ºé—´
	DataCount  int               `json:"dataCount"`  // æ•°æ®é¡¹æ•°é‡
	Age        string            `json:"age"`        // åˆ›å»ºæ—¶é—´
	CreatedAt  string            `json:"createdAt"`  // åˆ›å»ºæ—¶é—´ï¼ˆå®Œæ•´æ ¼å¼ï¼‰
	Labels     map[string]string `json:"labels"`     // æ ‡ç­¾
}

// ListConfigMaps è·å– ConfigMap åˆ—è¡¨
func (h *ResourceHandler) ListConfigMaps(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	configMaps, err := clientset.CoreV1().ConfigMaps(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "ConfigMap")
		return
	}

	configMapInfos := make([]ConfigMapInfo, 0, len(configMaps.Items))
	for _, cm := range configMaps.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := cm.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		configMapInfo := ConfigMapInfo{
			Name:      cm.Name,
			Namespace: cm.Namespace,
			DataCount: len(cm.Data),
			Age:       calculateAge(cm.CreationTimestamp.Time),
			CreatedAt: cm.CreationTimestamp.Format("2006-01-02 15:04:05"),
			Labels:    labels,
		}

		configMapInfos = append(configMapInfos, configMapInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    configMapInfos,
	})
}

// GetConfigMapYAML è·å– ConfigMap YAML
func (h *ResourceHandler) GetConfigMapYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	configMap, err := clientset.CoreV1().ConfigMaps(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "ConfigMap")
		return
	}

	// è½¬æ¢ä¸º YAML
	yamlData, err := yaml.Marshal(configMap)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "YAML è½¬æ¢å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"yaml": string(yamlData),
		},
	})
}

// UpdateConfigMapYAML æ›´æ–° ConfigMap YAML
func (h *ResourceHandler) UpdateConfigMapYAML(c *gin.Context) {
	var req struct {
		ClusterID int    `json:"clusterId"`
		YAML      string `json:"yaml"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è§£æ YAML
	var configMap v1.ConfigMap
	if err := yaml.Unmarshal([]byte(req.YAML), &configMap); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æ YAML å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ç¡®ä¿åç§°ä¸€è‡´
	configMap.Name = name
	configMap.Namespace = namespace

	// æ›´æ–° ConfigMap
	_, err = clientset.CoreV1().ConfigMaps(namespace).Update(c.Request.Context(), &configMap, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "ConfigMap")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteConfigMap åˆ é™¤ ConfigMap
func (h *ResourceHandler) DeleteConfigMap(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().ConfigMaps(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "ConfigMap")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// ==================== Secret ç›¸å…³ ====================

// SecretInfo Secret ä¿¡æ¯
type SecretInfo struct {
	Name       string            `json:"name"`       // Secret åç§°
	Namespace  string            `json:"namespace"`  // å‘½åç©ºé—´
	Type       string            `json:"type"`       // Secret ç±»å‹
	DataCount  int               `json:"dataCount"`  // æ•°æ®é¡¹æ•°é‡
	Age        string            `json:"age"`        // åˆ›å»ºæ—¶é—´
	Labels     map[string]string `json:"labels"`     // æ ‡ç­¾
}

// ListSecrets è·å– Secret åˆ—è¡¨
func (h *ResourceHandler) ListSecrets(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	secrets, err := clientset.CoreV1().Secrets(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Secret")
		return
	}

	secretInfos := make([]SecretInfo, 0, len(secrets.Items))
	for _, s := range secrets.Items {
		// ç¡®ä¿ labels ä¸ä¸º nil
		labels := s.Labels
		if labels == nil {
			labels = make(map[string]string)
		}

		secretInfo := SecretInfo{
			Name:      s.Name,
			Namespace: s.Namespace,
			Type:      string(s.Type),
			DataCount: len(s.Data),
			Age:       calculateAge(s.CreationTimestamp.Time),
			Labels:    labels,
		}

		secretInfos = append(secretInfos, secretInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data":    secretInfos,
	})
}

// GetSecretYAML è·å– Secret YAML
func (h *ResourceHandler) GetSecretYAML(c *gin.Context) {
	namespace := c.Param("namespace")
	name := c.Param("name")
	clusterIDStr := c.Query("clusterId")

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	secret, err := clientset.CoreV1().Secrets(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "Secret")
		return
	}

	// è½¬æ¢ä¸º YAML
	yamlData, err := yaml.Marshal(secret)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "YAML è½¬æ¢å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "success",
		"data": gin.H{
			"yaml": string(yamlData),
		},
	})
}

// UpdateSecretYAML æ›´æ–° Secret YAML
func (h *ResourceHandler) UpdateSecretYAML(c *gin.Context) {
	var req struct {
		ClusterID int    `json:"clusterId"`
		YAML      string `json:"yaml"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è¯·æ±‚å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(req.ClusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è§£æ YAML
	var secret v1.Secret
	if err := yaml.Unmarshal([]byte(req.YAML), &secret); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "è§£æ YAML å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ç¡®ä¿åç§°ä¸€è‡´
	secret.Name = name
	secret.Namespace = namespace

	// æ›´æ–° Secret
	_, err = clientset.CoreV1().Secrets(namespace).Update(c.Request.Context(), &secret, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "Secret")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// DeleteSecret åˆ é™¤ Secret
func (h *ResourceHandler) DeleteSecret(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().Secrets(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "Secret")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
		"data": gin.H{
			"needRefresh": true,
		},
	})
}

// GetPodLogs è·å–Podæ—¥å¿—
func (h *ResourceHandler) GetPodLogs(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	namespace := c.Query("namespace")
	podName := c.Query("podName")
	container := c.Query("container")
	tailLinesStr := c.DefaultQuery("tailLines", "100")

	if clusterIDStr == "" || namespace == "" || podName == "" || container == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å¿…è¦å‚æ•°: clusterId, namespace, podName, container",
		})
		return
	}

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	tailLines, err := strconv.ParseInt(tailLinesStr, 10, 64)
	if err != nil {
		tailLines = 100
	}

	// è·å–å½“å‰ç”¨æˆ·ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–Podæ—¥å¿—è¯·æ±‚
	podLogOptions := &v1.PodLogOptions{
		Container:  container,
		Timestamps: true,
	}

	// åªæœ‰å½“ tailLines > 0 æ—¶æ‰è®¾ç½® TailLines å‚æ•°
	// tailLines = 0 è¡¨ç¤ºè·å–å…¨éƒ¨æ—¥å¿—ï¼ˆä¸ä¼  TailLines å‚æ•°ï¼‰
	if tailLines > 0 {
		podLogOptions.TailLines = &tailLines
	}

	req := clientset.CoreV1().Pods(namespace).GetLogs(podName, podLogOptions)

	logStream, err := req.Stream(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–æ—¥å¿—å¤±è´¥: " + err.Error(),
		})
		return
	}
	defer logStream.Close()

	// è¯»å–æ—¥å¿—å†…å®¹
	logs, err := io.ReadAll(logStream)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è¯»å–æ—¥å¿—å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"logs": string(logs),
		},
	})
}

// GetPodsMetrics è·å–Podçš„å®é™…ä½¿ç”¨æŒ‡æ ‡ï¼ˆCPUå’Œå†…å­˜ï¼‰
func (h *ResourceHandler) GetPodsMetrics(c *gin.Context) {
	namespace := c.Query("namespace")
	clusterIDStr := c.Query("clusterId")

	if clusterIDStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å¿…è¦å‚æ•°: clusterId",
		})
		return
	}

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å– metrics clientset
	metricsClient, err := h.clusterService.GetCachedMetricsClientset(c.Request.Context(), uint(clusterID))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å– metrics client å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–æ‰€æœ‰ Pod metrics
	allPodMetrics, err := metricsClient.MetricsV1beta1().PodMetricses(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å– Pod metrics å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æ„å»ºè¿”å›æ•°æ®ï¼šmap[podName] -> metrics
	metricsMap := make(map[string]interface{})
	for _, pm := range allPodMetrics.Items {
		podName := pm.Name

		// CPU ä½¿ç”¨é‡ï¼ˆä» MilliCPU è½¬æ¢ï¼‰
		cpuUsage := int64(0)
		if pm.Containers != nil {
			for _, c := range pm.Containers {
				if c.Usage != nil {
					cpuUsage += c.Usage.Cpu().MilliValue()
				}
			}
		}

		// å†…å­˜ä½¿ç”¨é‡ï¼ˆä»å­—èŠ‚è½¬æ¢ï¼‰
		memoryUsage := int64(0)
		if pm.Containers != nil {
			for _, c := range pm.Containers {
				if c.Usage != nil {
					memoryUsage += c.Usage.Memory().Value()
				}
			}
		}

		metricsMap[podName] = map[string]interface{}{
			"cpu":       cpuUsage,    // æ¯«æ ¸
			"memory":    memoryUsage, // å­—èŠ‚
			"cpuStr":     formatCPUMetrics(cpuUsage),
			"memoryStr":  formatMemoryMetrics(memoryUsage),
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"metrics": metricsMap,
		},
	})
}

// formatCPUMetrics æ ¼å¼åŒ– CPU ä½¿ç”¨é‡
func formatCPUMetrics(milliValue int64) string {
	if milliValue == 0 {
		return "-"
	}
	if milliValue >= 1000 {
		return fmt.Sprintf("%.1f Core", float64(milliValue)/1000)
	}
	return fmt.Sprintf("%dm", milliValue)
}

// formatMemoryMetrics æ ¼å¼åŒ–å†…å­˜ä½¿ç”¨é‡
func formatMemoryMetrics(bytes int64) string {
	if bytes == 0 {
		return "-"
	}
	const (
		KB = 1024
		MB = 1024 * KB
		GB = 1024 * MB
	)
	if bytes >= GB {
		return fmt.Sprintf("%.1f Gi", float64(bytes)/float64(GB))
	}
	if bytes >= MB {
		return fmt.Sprintf("%.0f Mi", float64(bytes)/float64(MB))
	}
	if bytes >= KB {
		return fmt.Sprintf("%.0f Ki", float64(bytes)/float64(KB))
	}
	return fmt.Sprintf("%d B", bytes)
}

// PodShellWebSocket Podå®¹å™¨Shell WebSocketè¿æ¥
func (h *ResourceHandler) PodShellWebSocket(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	namespace := c.Query("namespace")
	podName := c.Query("podName")
	containerName := c.Query("container")

	if clusterIDStr == "" || namespace == "" || podName == "" || containerName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ç¼ºå°‘å¿…è¦å‚æ•°",
		})
		return
	}

	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ·IDï¼ˆä»è®¤è¯ä¸­é—´ä»¶è®¾ç½®çš„ context ä¸­è·å–ï¼‰
	currentUserID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"code":    401,
			"message": "æœªæˆæƒ",
		})
		return
	}

	// å‡çº§åˆ° WebSocket è¿æ¥
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("WebSocket upgrade failed: %v", err)
		return
	}
	defer conn.Close()

	fmt.Printf("ğŸš WebSocket shell connected to pod %s/%s, container %s, clusterID=%d\n", namespace, podName, containerName, clusterID)

	// è·å– REST config
	restConfig, err := h.clusterService.GetRESTConfig(uint(clusterID), currentUserID.(uint))
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("è·å–é›†ç¾¤é…ç½®å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// æ„é€  exec URL
	serverURL, err := url.Parse(restConfig.Host)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("è§£æé›†ç¾¤ URL å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// æ„é€  query å‚æ•°
	query := url.Values{}
	query.Set("container", containerName)
	query.Set("stdin", "true")
	query.Set("stdout", "true")
	query.Set("stderr", "true")
	query.Set("tty", "true")

	// æ·»åŠ è¦æ‰§è¡Œçš„å‘½ä»¤
	query.Add("command", "/bin/sh")
	query.Add("command", "-c")
	query.Add("command", "command -v bash >/dev/null 2>&1 && exec bash || exec sh")

	execURL := &url.URL{
		Scheme:   serverURL.Scheme,
		Host:     serverURL.Host,
		Path:     fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", namespace, podName),
		RawQuery: query.Encode(),
	}

	fmt.Printf("ğŸš Exec URL: %s\n", execURL.String())

	// åˆ›å»º SPDY executor
	executor, err := remotecommand.NewSPDYExecutor(restConfig, "POST", execURL)
	if err != nil {
		conn.WriteMessage(websocket.TextMessage, []byte("åˆ›å»º executor å¤±è´¥: "+err.Error()+"\r\n"))
		return
	}

	// åˆ›å»º WebSocket è¯»å†™å™¨
	wsReader := &WebSocketReader{
		conn: conn,
		data: make(chan []byte, 256),
	}
	wsWriter := &WebSocketWriter{conn: conn}

	// å¤„ç† WebSocket æ¶ˆæ¯
	done := make(chan struct{})
	go func() {
		defer close(done)
		for {
			_, message, err := conn.ReadMessage()
			if err != nil {
				if err != websocket.ErrCloseSent {
					fmt.Printf("ğŸš WebSocket read error: %v\n", err)
				}
				return
			}
			wsReader.data <- message
		}
	}()

	// æµå¼å¤„ç†
	err = executor.StreamWithContext(context.Background(), remotecommand.StreamOptions{
		Stdin:  wsReader,
		Stdout: wsWriter,
		Stderr: wsWriter,
		Tty:    true,
	})

	if err != nil {
		fmt.Printf("ğŸš Executor error: %v\n", err)
	}

	// ç­‰å¾…è¯»å– goroutine ç»“æŸ
	<-done
	fmt.Printf("ğŸš WebSocket connection closed for pod %s/%s\n", namespace, podName)
}

// PauseWorkload æš‚åœ/æ¢å¤å·¥ä½œè´Ÿè½½
func (h *ResourceHandler) PauseWorkload(c *gin.Context) {
	fmt.Printf("ğŸ¯ PauseWorkload called\n")

	var req struct {
		ClusterID  uint   `json:"clusterId" binding:"required"`
		Namespace  string `json:"namespace" binding:"required"`
		Name       string `json:"name" binding:"required"`
		Type       string `json:"type" binding:"required"`
		Paused     bool   `json:"paused"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		fmt.Printf("âŒ Bind error: %v\n", err)
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… Parsed: ClusterID=%d, Namespace=%s, Name=%s, Type=%s, Paused=%v\n",
		req.ClusterID, req.Namespace, req.Name, req.Type, req.Paused)

	// è·å– clientset
	clientset, err := h.clusterService.GetCachedClientset(c.Request.Context(), req.ClusterID)
	if err != nil {
		fmt.Printf("âŒ GetCachedClientset error: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤ clientset å¤±è´¥: " + err.Error(),
		})
		return
	}
	fmt.Printf("âœ… Got clientset\n")

	switch req.Type {
	case "Deployment":
		fmt.Printf("ğŸ“¦ Processing Deployment...\n")
		deployment, err := clientset.AppsV1().Deployments(req.Namespace).Get(c.Request.Context(), req.Name, metav1.GetOptions{})
		if err != nil {
			fmt.Printf("âŒ Get Deployment error: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å– Deployment å¤±è´¥: " + err.Error(),
			})
			return
		}
		fmt.Printf("âœ… Got Deployment, current paused=%v\n", deployment.Spec.Paused)

		// æ›´æ–°æš‚åœçŠ¶æ€
		deployment.Spec.Paused = req.Paused
		fmt.Printf("ğŸ“ Setting paused to %v\n", req.Paused)

		updatedDeployment, err := clientset.AppsV1().Deployments(req.Namespace).Update(c.Request.Context(), deployment, metav1.UpdateOptions{})
		if err != nil {
			fmt.Printf("âŒ Update Deployment error: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "æ›´æ–° Deployment å¤±è´¥: " + err.Error(),
			})
			return
		}
		fmt.Printf("âœ… Deployment updated, new paused=%v\n", updatedDeployment.Spec.Paused)

	default:
		fmt.Printf("âŒ Unsupported workload type: %s\n", req.Type)
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + req.Type,
		})
		return
	}

	fmt.Printf("âœ… Sending success response\n")
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ“ä½œæˆåŠŸ",
		"data": gin.H{
			"paused": req.Paused,
		},
	})
}

// RollbackWorkload å›æ»šå·¥ä½œè´Ÿè½½åˆ°æŒ‡å®šç‰ˆæœ¬
func (h *ResourceHandler) RollbackWorkload(c *gin.Context) {
	fmt.Printf("ğŸ”„ RollbackWorkload called\n")

	var req struct {
		ClusterID  uint   `json:"clusterId" binding:"required"`
		Namespace  string `json:"namespace" binding:"required"`
		Name       string `json:"name" binding:"required"`
		Type       string `json:"type" binding:"required"`
		Revision   string `json:"revision" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		fmt.Printf("âŒ Bind error: %v\n", err)
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "å‚æ•°é”™è¯¯: " + err.Error(),
		})
		return
	}

	fmt.Printf("âœ… Parsed: ClusterID=%d, Namespace=%s, Name=%s, Type=%s, Revision=%s\n",
		req.ClusterID, req.Namespace, req.Name, req.Type, req.Revision)

	// è·å– clientset
	clientset, err := h.clusterService.GetCachedClientset(c.Request.Context(), req.ClusterID)
	if err != nil {
		fmt.Printf("âŒ GetCachedClientset error: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤ clientset å¤±è´¥: " + err.Error(),
		})
		return
	}
	fmt.Printf("âœ… Got clientset\n")

	switch req.Type {
	case "Deployment":
		fmt.Printf("ğŸ“¦ Processing Deployment rollback...\n")

		// ä½¿ç”¨ Kubernetes Rollback API (å¦‚æœå¯ç”¨) æˆ–è€…æ‰‹åŠ¨å›æ»š
		// æ³¨æ„ï¼šKubernetes 1.15+ ç§»é™¤äº† rollout undo å‘½ä»¤ï¼Œéœ€è¦ä½¿ç”¨å…¶ä»–æ–¹å¼
		// è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åˆ›å»ºæ–°çš„ ReplicaSet çš„æ–¹å¼æ¥å›æ»š

		// é¦–å…ˆæ‰¾åˆ°å¯¹åº”ç‰ˆæœ¬çš„ ReplicaSet
		replicaSets, err := clientset.AppsV1().ReplicaSets(req.Namespace).List(c.Request.Context(), metav1.ListOptions{
			LabelSelector: fmt.Sprintf("app=%s", req.Name), // å‡è®¾æœ‰ app æ ‡ç­¾
		})
		if err != nil {
			fmt.Printf("âŒ List ReplicaSets error: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å– ReplicaSet åˆ—è¡¨å¤±è´¥: " + err.Error(),
			})
			return
		}

		// æ‰¾åˆ°åŒ¹é… revision çš„ ReplicaSet
		var targetReplicaSet *appsv1.ReplicaSet
		for i := range replicaSets.Items {
			rs := &replicaSets.Items[i]
			revision := rs.Annotations["deployment.kubernetes.io/revision"]
			if revision == req.Revision {
				targetReplicaSet = rs
				break
			}
		}

		if targetReplicaSet == nil {
			fmt.Printf("âŒ Target ReplicaSet not found for revision %s\n", req.Revision)
			c.JSON(http.StatusNotFound, gin.H{
				"code":    404,
				"message": "æœªæ‰¾åˆ°æŒ‡å®šç‰ˆæœ¬çš„ ReplicaSet",
			})
			return
		}

		fmt.Printf("âœ… Found target ReplicaSet: %s\n", targetReplicaSet.Name)

		// è·å–å½“å‰ Deployment
		deployment, err := clientset.AppsV1().Deployments(req.Namespace).Get(c.Request.Context(), req.Name, metav1.GetOptions{})
		if err != nil {
			fmt.Printf("âŒ Get Deployment error: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "è·å– Deployment å¤±è´¥: " + err.Error(),
			})
			return
		}

		// æ›´æ–° Deployment çš„ template æ¥åŒ¹é…ç›®æ ‡ ReplicaSet
		deployment.Spec.Template = targetReplicaSet.Spec.Template

		// æ›´æ–° Deployment
		_, err = clientset.AppsV1().Deployments(req.Namespace).Update(c.Request.Context(), deployment, metav1.UpdateOptions{})
		if err != nil {
			fmt.Printf("âŒ Update Deployment error: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"code":    500,
				"message": "å›æ»š Deployment å¤±è´¥: " + err.Error(),
			})
			return
		}

		fmt.Printf("âœ… Deployment rolled back successfully\n")

	default:
		fmt.Printf("âŒ Unsupported workload type: %s\n", req.Type)
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "ä¸æ”¯æŒçš„å·¥ä½œè´Ÿè½½ç±»å‹: " + req.Type,
		})
		return
	}

	fmt.Printf("âœ… Sending success response\n")
	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "å›æ»šæˆåŠŸ",
		"data": gin.H{
			"revision": req.Revision,
		},
	})
}

// FileInfo æ–‡ä»¶ä¿¡æ¯
type FileInfo struct {
	Name    string `json:"name"`
	Size    string `json:"size"`
	Mode    string `json:"mode"`
	IsDir   bool   `json:"isDir"`
	ModTime string `json:"modTime"`
	User    string `json:"user"`
	Group   string `json:"group"`
	Link    string `json:"link"`
	Path    string `json:"path"`
}

// ListContainerFiles åˆ—å‡ºå®¹å™¨æ–‡ä»¶
func (h *ResourceHandler) ListContainerFiles(c *gin.Context) {
	clusterIDStr := c.Query("cluster_id")
	if clusterIDStr == "" {
		clusterIDStr = c.Query("clusterId")
	}
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	podName := c.Query("podName")
	containerName := c.Query("containerName")
	path := c.Query("path")

	if namespace == "" || podName == "" || containerName == "" {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "ç¼ºå°‘å¿…è¦å‚æ•°",
		})
		return
	}

	if path == "" {
		path = "/"
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	restConfig, err := h.clusterService.GetRESTConfig(uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è·å–é›†ç¾¤é…ç½®å¤±è´¥: " + err.Error(),
		})
		return
	}

	serverURL, err := url.Parse(restConfig.Host)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è§£æé›†ç¾¤ URL å¤±è´¥: " + err.Error(),
		})
		return
	}

	query := url.Values{}
	query.Set("container", containerName)
	query.Set("stdin", "true")
	query.Set("stdout", "true")
	query.Set("stderr", "true")
	query.Set("tty", "false")

	cmdStr := fmt.Sprintf("ls -la '%s'", path)
	query.Add("command", "sh")
	query.Add("command", "-c")
	query.Add("command", cmdStr)

	execURL := &url.URL{
		Scheme:   serverURL.Scheme,
		Host:     serverURL.Host,
		Path:     fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", namespace, podName),
		RawQuery: query.Encode(),
	}

	executor, err := remotecommand.NewSPDYExecutor(restConfig, "POST", execURL)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "åˆ›å»º executor å¤±è´¥: " + err.Error(),
		})
		return
	}

	var stdout bytes.Buffer
	var stderr bytes.Buffer

	pr, pw := io.Pipe()
	defer pr.Close()
	defer pw.Close()

	go func() {
		pw.Close()
	}()

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	err = executor.StreamWithContext(ctx, remotecommand.StreamOptions{
		Stdin:  pr,
		Stdout: &stdout,
		Stderr: &stderr,
		Tty:    false,
	})

	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "æ‰§è¡Œå‘½ä»¤å¤±è´¥: " + err.Error(),
		})
		return
	}

	output := stdout.String()
	files := parseLsOutput(output)

	c.JSON(http.StatusOK, gin.H{
		"code": 0,
		"data": gin.H{
			"files": files,
		},
		"msg": "è·å–æˆåŠŸ",
	})
}

// DownloadContainerFile ä¸‹è½½å®¹å™¨æ–‡ä»¶
func (h *ResourceHandler) DownloadContainerFile(c *gin.Context) {
	clusterIDStr := c.Query("cluster_id")
	if clusterIDStr == "" {
		clusterIDStr = c.Query("clusterId")
	}
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	podName := c.Query("podName")
	containerName := c.Query("containerName")
	path := c.Query("path")

	if namespace == "" || podName == "" || containerName == "" || path == "" {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "ç¼ºå°‘å¿…è¦å‚æ•°",
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	restConfig, err := h.clusterService.GetRESTConfig(uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è·å–é›†ç¾¤é…ç½®å¤±è´¥: " + err.Error(),
		})
		return
	}

	serverURL, err := url.Parse(restConfig.Host)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è§£æé›†ç¾¤ URL å¤±è´¥: " + err.Error(),
		})
		return
	}

	query := url.Values{}
	query.Set("container", containerName)
	query.Set("stdin", "true")
	query.Set("stdout", "true")
	query.Set("stderr", "true")
	query.Set("tty", "false")

	cmdStr := fmt.Sprintf("cat '%s' | base64", path)
	query.Add("command", "sh")
	query.Add("command", "-c")
	query.Add("command", cmdStr)

	execURL := &url.URL{
		Scheme:   serverURL.Scheme,
		Host:     serverURL.Host,
		Path:     fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", namespace, podName),
		RawQuery: query.Encode(),
	}

	executor, err := remotecommand.NewSPDYExecutor(restConfig, "POST", execURL)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "åˆ›å»º executor å¤±è´¥: " + err.Error(),
		})
		return
	}

	var stdout bytes.Buffer
	var stderr bytes.Buffer

	pr, pw := io.Pipe()
	defer pr.Close()
	defer pw.Close()

	go func() {
		pw.Close()
	}()

	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
	defer cancel()

	err = executor.StreamWithContext(ctx, remotecommand.StreamOptions{
		Stdin:  pr,
		Stdout: &stdout,
		Stderr: &stderr,
		Tty:    false,
	})

	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è¯»å–æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	decodedData, err := base64.StdEncoding.DecodeString(stdout.String())
	if err != nil {
		decodedData = stdout.Bytes()
	}

	c.Header("Content-Type", "application/octet-stream")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filepath.Base(path)))
	c.Data(http.StatusOK, "application/octet-stream", decodedData)
}

// UploadContainerFile ä¸Šä¼ æ–‡ä»¶åˆ°å®¹å™¨
func (h *ResourceHandler) UploadContainerFile(c *gin.Context) {
	clusterIDStr := c.PostForm("cluster_id")
	if clusterIDStr == "" {
		clusterIDStr = c.PostForm("clusterId")
	}
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.PostForm("namespace")
	podName := c.PostForm("podName")
	containerName := c.PostForm("containerName")
	path := c.PostForm("path")

	if namespace == "" || podName == "" || containerName == "" || path == "" {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "ç¼ºå°‘å¿…è¦å‚æ•°",
		})
		return
	}

	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 400,
			"msg":  "è·å–ä¸Šä¼ æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	src, err := file.Open()
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "æ‰“å¼€æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}
	defer src.Close()

	fileData, err := io.ReadAll(src)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è¯»å–æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	restConfig, err := h.clusterService.GetRESTConfig(uint(clusterID), currentUserID)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è·å–é›†ç¾¤é…ç½®å¤±è´¥: " + err.Error(),
		})
		return
	}

	serverURL, err := url.Parse(restConfig.Host)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "è§£æé›†ç¾¤ URL å¤±è´¥: " + err.Error(),
		})
		return
	}

	query := url.Values{}
	query.Set("container", containerName)
	query.Set("stdin", "true")
	query.Set("stdout", "true")
	query.Set("stderr", "true")
	query.Set("tty", "false")

	encodedContent := base64.StdEncoding.EncodeToString(fileData)
	cmdStr := fmt.Sprintf("echo '%s' | base64 -d > '%s'", encodedContent, path)
	query.Add("command", "sh")
	query.Add("command", "-c")
	query.Add("command", cmdStr)

	execURL := &url.URL{
		Scheme:   serverURL.Scheme,
		Host:     serverURL.Host,
		Path:     fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", namespace, podName),
		RawQuery: query.Encode(),
	}

	executor, err := remotecommand.NewSPDYExecutor(restConfig, "POST", execURL)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "åˆ›å»º executor å¤±è´¥: " + err.Error(),
		})
		return
	}

	var stdout bytes.Buffer
	var stderr bytes.Buffer

	pr, pw := io.Pipe()
	defer pr.Close()
	defer pw.Close()

	go func() {
		pw.Close()
	}()

	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
	defer cancel()

	err = executor.StreamWithContext(ctx, remotecommand.StreamOptions{
		Stdin:  pr,
		Stdout: &stdout,
		Stderr: &stderr,
		Tty:    false,
	})

	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"code": 500,
			"msg":  "ä¸Šä¼ æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code": 0,
		"msg":  "æ–‡ä»¶ä¸Šä¼ æˆåŠŸ",
	})
}

// parseLsOutput è§£æ ls -la å‘½ä»¤çš„è¾“å‡º
func parseLsOutput(output string) []FileInfo {
	lines := strings.Split(output, "\n")
	var files []FileInfo

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "total") || strings.HasPrefix(line, "ERROR:") {
			continue
		}

		fields := strings.Fields(line)
		if len(fields) < 8 {
			continue
		}

		fileInfo := FileInfo{
			Mode:  fields[0],
			User:  fields[2],
			Group: fields[3],
			Size:  fields[4],
		}

		fileInfo.IsDir = strings.HasPrefix(fileInfo.Mode, "d")

		nameAndLink := strings.Join(fields[8:], " ")

		if idx := strings.Index(nameAndLink, " -> "); idx > 0 {
			fileInfo.Name = nameAndLink[:idx]
			fileInfo.Link = nameAndLink[idx+4:]
		} else {
			fileInfo.Name = nameAndLink
		}

		if fileInfo.Name == "." || fileInfo.Name == ".." {
			continue
		}

		if len(fields) >= 8 {
			timeStr := strings.Join(fields[5:8], " ")
			fileInfo.ModTime = timeStr
		}

		files = append(files, fileInfo)
	}

	return files
}

// ==================== Storage ç›¸å…³ ====================

// PVCInfo PersistentVolumeClaim ä¿¡æ¯
type PVCInfo struct {
	Name         string            `json:"name"`         // PVC åç§°
	Namespace    string            `json:"namespace"`    // å‘½åç©ºé—´
	Status       string            `json:"status"`       // çŠ¶æ€
	Capacity     string            `json:"capacity"`     // å®¹é‡
	AccessModes  []string          `json:"accessModes"`  // è®¿é—®æ¨¡å¼
	StorageClass string            `json:"storageClass"` // å­˜å‚¨ç±»
	VolumeName   string            `json:"volumeName"`   // ç»‘å®šçš„ PV åç§°
	Age          string            `json:"age"`          // åˆ›å»ºæ—¶é—´
	Labels       map[string]string `json:"labels"`       // æ ‡ç­¾
}

// PVInfo PersistentVolume ä¿¡æ¯
type PVInfo struct {
	Name           string            `json:"name"`           // PV åç§°
	Capacity       string            `json:"capacity"`       // å®¹é‡
	AccessModes    []string          `json:"accessModes"`    // è®¿é—®æ¨¡å¼
	ReclaimPolicy  string            `json:"reclaimPolicy"`  // å›æ”¶ç­–ç•¥
	Status         string            `json:"status"`         // çŠ¶æ€
	Claim          string            `json:"claim"`          // ç»‘å®šçš„ PVC (namespace/name)
	StorageClass   string            `json:"storageClass"`   // å­˜å‚¨ç±»
	Reason         string            `json:"reason"`         // å¤„äºå½“å‰çŠ¶æ€çš„åŸå› 
	Age            string            `json:"age"`            // åˆ›å»ºæ—¶é—´
	Labels         map[string]string `json:"labels"`         // æ ‡ç­¾
}

// StorageClassInfo StorageClass ä¿¡æ¯
type StorageClassInfo struct {
	Name                  string            `json:"name"`                  // StorageClass åç§°
	Provisioner           string            `json:"provisioner"`           // Provisioner
	ReclaimPolicy         string            `json:"reclaimPolicy"`         // å›æ”¶ç­–ç•¥
	VolumeBindingMode     string            `json:"volumeBindingMode"`     // ç»‘å®šæ¨¡å¼
	AllowVolumeExpansion  bool              `json:"allowVolumeExpansion"`  // å…è®¸å·æ‰©å±•
	Age                   string            `json:"age"`                   // åˆ›å»ºæ—¶é—´
	Labels                map[string]string `json:"labels"`                // æ ‡ç­¾
}

// ListPersistentVolumeClaims è·å– PVC åˆ—è¡¨
func (h *ResourceHandler) ListPersistentVolumeClaims(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		namespace = v1.NamespaceAll
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	pvcs, err := clientset.CoreV1().PersistentVolumeClaims(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	result := make([]PVCInfo, 0, len(pvcs.Items))
	for _, pvc := range pvcs.Items {
		accessModes := make([]string, len(pvc.Spec.AccessModes))
		for i, am := range pvc.Spec.AccessModes {
			accessModes[i] = string(am)
		}

		capacity := ""
		if pvc.Spec.Resources.Requests != nil {
			if storage, ok := pvc.Spec.Resources.Requests[v1.ResourceStorage]; ok {
				capacity = storage.String()
			}
		}

		storageClass := ""
		if pvc.Spec.StorageClassName != nil {
			storageClass = *pvc.Spec.StorageClassName
		}

		volumeName := ""
		if pvc.Spec.VolumeName != "" {
			volumeName = pvc.Spec.VolumeName
		}

		claim := PVCInfo{
			Name:         pvc.Name,
			Namespace:    pvc.Namespace,
			Status:       string(pvc.Status.Phase),
			Capacity:     capacity,
			AccessModes:  accessModes,
			StorageClass: storageClass,
			VolumeName:   volumeName,
			Age:          calculateAge(pvc.CreationTimestamp.Time),
			Labels:       pvc.Labels,
		}
		result = append(result, claim)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    result,
	})
}

// GetPersistentVolumeClaimYAML è·å– PVC YAML
func (h *ResourceHandler) GetPersistentVolumeClaimYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	pvc, err := clientset.CoreV1().PersistentVolumeClaims(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    pvc,
	})
}

// UpdatePersistentVolumeClaimYAML æ›´æ–° PVC YAML
func (h *ResourceHandler) UpdatePersistentVolumeClaimYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„è¯·æ±‚æ•°æ®: " + err.Error(),
		})
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–ç°æœ‰ PVC ä»¥ä¿ç•™èµ„æºç‰ˆæœ¬ç­‰ä¿¡æ¯
	existingPVC, err := clientset.CoreV1().PersistentVolumeClaims(namespace).Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	// å°† jsonData è½¬æ¢ä¸º PVC å¯¹è±¡
	var pvc v1.PersistentVolumeClaim
	pvcData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = json.Unmarshal(pvcData, &pvc)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è§£æ PVC æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ä¿ç•™èµ„æºç‰ˆæœ¬ï¼Œç¡®ä¿æ›´æ–°æˆåŠŸ
	pvc.ResourceVersion = existingPVC.ResourceVersion

	_, err = clientset.CoreV1().PersistentVolumeClaims(namespace).Update(c.Request.Context(), &pvc, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
	})
}

// DeletePersistentVolumeClaim åˆ é™¤ PVC
func (h *ResourceHandler) DeletePersistentVolumeClaim(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")
	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().PersistentVolumeClaims(namespace).Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
	})
}

// ListPersistentVolumes è·å– PV åˆ—è¡¨
func (h *ResourceHandler) ListPersistentVolumes(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	pvs, err := clientset.CoreV1().PersistentVolumes().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "PV")
		return
	}

	result := make([]PVInfo, 0, len(pvs.Items))
	for _, pv := range pvs.Items {
		accessModes := make([]string, len(pv.Spec.AccessModes))
		for i, am := range pv.Spec.AccessModes {
			accessModes[i] = string(am)
		}

		capacity := ""
		if pv.Spec.Capacity != nil {
			if storage, ok := pv.Spec.Capacity[v1.ResourceStorage]; ok {
				capacity = storage.String()
			}
		}

		reclaimPolicy := string(pv.Spec.PersistentVolumeReclaimPolicy)

		claim := ""
		if pv.Spec.ClaimRef != nil {
			claim = pv.Spec.ClaimRef.Namespace + "/" + pv.Spec.ClaimRef.Name
		}

		storageClass := pv.Spec.StorageClassName

		reason := ""
		if pv.Status.Reason != "" {
			reason = pv.Status.Reason
		}

		volume := PVInfo{
			Name:          pv.Name,
			Capacity:      capacity,
			AccessModes:   accessModes,
			ReclaimPolicy: reclaimPolicy,
			Status:        string(pv.Status.Phase),
			Claim:         claim,
			StorageClass:  storageClass,
			Reason:        reason,
			Age:           calculateAge(pv.CreationTimestamp.Time),
			Labels:        pv.Labels,
		}
		result = append(result, volume)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    result,
	})
}

// GetPersistentVolumeYAML è·å– PV YAML
func (h *ResourceHandler) GetPersistentVolumeYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	pv, err := clientset.CoreV1().PersistentVolumes().Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "PV")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    pv,
	})
}

// UpdatePersistentVolumeYAML æ›´æ–° PV YAML
func (h *ResourceHandler) UpdatePersistentVolumeYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„è¯·æ±‚æ•°æ®: " + err.Error(),
		})
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–ç°æœ‰ PV ä»¥ä¿ç•™èµ„æºç‰ˆæœ¬ç­‰ä¿¡æ¯
	existingPV, err := clientset.CoreV1().PersistentVolumes().Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "PV")
		return
	}

	// å°† jsonData è½¬æ¢ä¸º PV å¯¹è±¡
	var pv v1.PersistentVolume
	pvData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = json.Unmarshal(pvData, &pv)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è§£æ PV æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ä¿ç•™èµ„æºç‰ˆæœ¬ï¼Œç¡®ä¿æ›´æ–°æˆåŠŸ
	pv.ResourceVersion = existingPV.ResourceVersion

	_, err = clientset.CoreV1().PersistentVolumes().Update(c.Request.Context(), &pv, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "PV")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
	})
}

// DeletePersistentVolume åˆ é™¤ PV
func (h *ResourceHandler) DeletePersistentVolume(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.CoreV1().PersistentVolumes().Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "PV")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
	})
}

// ListStorageClasses è·å– StorageClass åˆ—è¡¨
func (h *ResourceHandler) ListStorageClasses(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	// ä½¿ç”¨ç”¨æˆ·å‡­æ®è·å– clientset
	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	scs, err := clientset.StorageV1().StorageClasses().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "StorageClass")
		return
	}

	result := make([]StorageClassInfo, 0, len(scs.Items))
	for _, sc := range scs.Items {
		reclaimPolicy := ""
		if sc.ReclaimPolicy != nil {
			reclaimPolicy = string(*sc.ReclaimPolicy)
		}

		volumeBindingMode := ""
		if sc.VolumeBindingMode != nil {
			volumeBindingMode = string(*sc.VolumeBindingMode)
		}

		allowVolumeExpansion := false
		if sc.AllowVolumeExpansion != nil {
			allowVolumeExpansion = *sc.AllowVolumeExpansion
		}

		classInfo := StorageClassInfo{
			Name:                 sc.Name,
			Provisioner:          sc.Provisioner,
			ReclaimPolicy:        reclaimPolicy,
			VolumeBindingMode:    volumeBindingMode,
			AllowVolumeExpansion: allowVolumeExpansion,
			Age:                  calculateAge(sc.CreationTimestamp.Time),
			Labels:               sc.Labels,
		}
		result = append(result, classInfo)
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    result,
	})
}

// GetStorageClassYAML è·å– StorageClass YAML
func (h *ResourceHandler) GetStorageClassYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	sc, err := clientset.StorageV1().StorageClasses().Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "StorageClass")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "è·å–æˆåŠŸ",
		"data":    sc,
	})
}

// UpdateStorageClassYAML æ›´æ–° StorageClass YAML
func (h *ResourceHandler) UpdateStorageClassYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„è¯·æ±‚æ•°æ®: " + err.Error(),
		})
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è·å–ç°æœ‰ StorageClass ä»¥ä¿ç•™èµ„æºç‰ˆæœ¬ç­‰ä¿¡æ¯
	existingSC, err := clientset.StorageV1().StorageClasses().Get(c.Request.Context(), name, metav1.GetOptions{})
	if err != nil {
		HandleK8sError(c, err, "StorageClass")
		return
	}

	// å°† jsonData è½¬æ¢ä¸º StorageClass å¯¹è±¡
	var sc storagev1.StorageClass
	scData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = json.Unmarshal(scData, &sc)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è§£æ StorageClass æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ä¿ç•™èµ„æºç‰ˆæœ¬ï¼Œç¡®ä¿æ›´æ–°æˆåŠŸ
	sc.ResourceVersion = existingSC.ResourceVersion

	_, err = clientset.StorageV1().StorageClasses().Update(c.Request.Context(), &sc, metav1.UpdateOptions{})
	if err != nil {
		HandleK8sError(c, err, "StorageClass")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "æ›´æ–°æˆåŠŸ",
	})
}

// DeleteStorageClass åˆ é™¤ StorageClass
func (h *ResourceHandler) DeleteStorageClass(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	name := c.Param("name")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = clientset.StorageV1().StorageClasses().Delete(c.Request.Context(), name, metav1.DeleteOptions{})
	if err != nil {
		HandleK8sError(c, err, "StorageClass")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ é™¤æˆåŠŸ",
	})
}

// CreatePersistentVolumeClaimYAML é€šè¿‡ YAML åˆ›å»º PVC
func (h *ResourceHandler) CreatePersistentVolumeClaimYAML(c *gin.Context) {
	clusterIDStr := c.Param("clusterId")
	clusterID, err := strconv.ParseUint(clusterIDStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„é›†ç¾¤ID",
		})
		return
	}

	namespace := c.Param("namespace")

	// è·å–å½“å‰ç”¨æˆ· ID
	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	var jsonData map[string]interface{}
	if err := c.ShouldBindJSON(&jsonData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"code":    400,
			"message": "æ— æ•ˆçš„è¯·æ±‚æ•°æ®: " + err.Error(),
		})
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è·å–é›†ç¾¤è¿æ¥å¤±è´¥: " + err.Error(),
		})
		return
	}

	// å°† jsonData è½¬æ¢ä¸º PVC å¯¹è±¡
	var pvc v1.PersistentVolumeClaim
	pvcData, err := json.Marshal(jsonData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "åºåˆ—åŒ–æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	err = json.Unmarshal(pvcData, &pvc)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"code":    500,
			"message": "è§£æ PVC æ•°æ®å¤±è´¥: " + err.Error(),
		})
		return
	}

	_, err = clientset.CoreV1().PersistentVolumeClaims(namespace).Create(c.Request.Context(), &pvc, metav1.CreateOptions{})
	if err != nil {
		HandleK8sError(c, err, "PVC")
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"code":    0,
		"message": "åˆ›å»ºæˆåŠŸ",
	})
}

// ==================== è®¿é—®æ§åˆ¶èµ„æºç›¸å…³ ====================

// ListServiceAccounts è·å–ServiceAccountåˆ—è¡¨
func (h *ResourceHandler) ListServiceAccounts(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ— æ•ˆçš„é›†ç¾¤ID"})
		return
	}

	namespace := c.Query("namespace")

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	var list *v1.ServiceAccountList
	if namespace != "" {
		list, err = clientset.CoreV1().ServiceAccounts(namespace).List(c.Request.Context(), metav1.ListOptions{})
	} else {
		list, err = clientset.CoreV1().ServiceAccounts("").List(c.Request.Context(), metav1.ListOptions{})
	}

	if err != nil {
		HandleK8sError(c, err, "ServiceAccount")
		return
	}

	result := make([]gin.H, 0, len(list.Items))
	for _, sa := range list.Items {
		secrets := make([]string, 0, len(sa.Secrets))
		for _, s := range sa.Secrets {
			secrets = append(secrets, s.Name)
		}
		result = append(result, gin.H{
			"name":      sa.Name,
			"namespace": sa.Namespace,
			"secrets":   secrets,
			"age":       calculateAge(sa.CreationTimestamp.Time),
			"labels":    sa.Labels,
		})
	}

	c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": result})
}

// ListRoles è·å–Roleåˆ—è¡¨
func (h *ResourceHandler) ListRoles(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ— æ•ˆçš„é›†ç¾¤ID"})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "å‘½åç©ºé—´ä¸èƒ½ä¸ºç©º"})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	list, err := clientset.RbacV1().Roles(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "Role")
		return
	}

	result := make([]gin.H, 0, len(list.Items))
	for _, role := range list.Items {
		result = append(result, gin.H{
			"name":     role.Name,
			"namespace": role.Namespace,
			"age":      calculateAge(role.CreationTimestamp.Time),
			"labels":   role.Labels,
			"rules":    role.Rules,
		})
	}

	c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": result})
}

// ListRoleBindings è·å–RoleBindingåˆ—è¡¨
func (h *ResourceHandler) ListRoleBindings(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ— æ•ˆçš„é›†ç¾¤ID"})
		return
	}

	namespace := c.Query("namespace")
	if namespace == "" {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "å‘½åç©ºé—´ä¸èƒ½ä¸ºç©º"})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	list, err := clientset.RbacV1().RoleBindings(namespace).List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "RoleBinding")
		return
	}

	result := make([]gin.H, 0, len(list.Items))
	for _, rb := range list.Items {
		roleKind := "Role"
		roleName := ""
		if rb.RoleRef.Kind == "ClusterRole" {
			roleKind = "ClusterRole"
		}
		roleName = rb.RoleRef.Name

		subjects := make([]gin.H, 0, len(rb.Subjects))
		for _, s := range rb.Subjects {
			subjects = append(subjects, gin.H{
				"kind":      s.Kind,
				"name":      s.Name,
				"namespace": s.Namespace,
			})
		}

		result = append(result, gin.H{
			"name":      rb.Name,
			"namespace": rb.Namespace,
			"roleKind":  roleKind,
			"roleName":  roleName,
			"subjects":  subjects,
			"age":       calculateAge(rb.CreationTimestamp.Time),
			"labels":    rb.Labels,
		})
	}

	c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": result})
}

// ListClusterRoleBindings è·å–ClusterRoleBindingåˆ—è¡¨
func (h *ResourceHandler) ListClusterRoleBindings(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ— æ•ˆçš„é›†ç¾¤ID"})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	list, err := clientset.RbacV1().ClusterRoleBindings().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		HandleK8sError(c, err, "ClusterRoleBinding")
		return
	}

	result := make([]gin.H, 0, len(list.Items))
	for _, crb := range list.Items {
		subjects := make([]gin.H, 0, len(crb.Subjects))
		for _, s := range crb.Subjects {
			subjects = append(subjects, gin.H{
				"kind":      s.Kind,
				"name":      s.Name,
				"namespace": s.Namespace,
			})
		}

		result = append(result, gin.H{
			"name":      crb.Name,
			"roleName":  crb.RoleRef.Name,
			"subjects":  subjects,
			"age":       calculateAge(crb.CreationTimestamp.Time),
			"labels":    crb.Labels,
		})
	}

	c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": result})
}

// ListPodSecurityPolicies è·å–PodSecurityPolicyåˆ—è¡¨
func (h *ResourceHandler) ListPodSecurityPolicies(c *gin.Context) {
	clusterIDStr := c.Query("clusterId")
	clusterID, err := strconv.Atoi(clusterIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ— æ•ˆçš„é›†ç¾¤ID"})
		return
	}

	currentUserID, ok := GetCurrentUserID(c)
	if !ok {
		return
	}

	clientset, err := h.clusterService.GetClientsetForUser(c.Request.Context(), uint(clusterID), currentUserID)
	if err != nil {
		if h.handleGetClientsetError(c, err) {
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å–é›†ç¾¤å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	// PodSecurityPolicy åœ¨ v1beta1 ä¸­ï¼Œéœ€è¦ä½¿ç”¨ policy client
	policyClient, err := policyv1beta1.NewForConfig(clientset.Discovery().RESTClient().Config())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "è·å– Policy å®¢æˆ·ç«¯å¤±è´¥"})
		return
	}

	list, err := policyClient.PodSecurityPolicies().List(c.Request.Context(), metav1.ListOptions{})
	if err != nil {
		// å¦‚æœ PodSecurityPolicy ä¸å¯ç”¨ï¼ˆå¯èƒ½å·²è¢«ç¦ç”¨ï¼‰ï¼Œè¿”å›ç©ºåˆ—è¡¨
		c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": []gin.H{}})
		return
	}

	result := make([]gin.H, 0, len(list.Items))
	for _, psp := range list.Items {
		result = append(result, gin.H{
			"name":   psp.Name,
			"age":    calculateAge(psp.CreationTimestamp.Time),
			"labels": psp.Labels,
			"spec":   psp.Spec,
		})
	}

	c.JSON(http.StatusOK, gin.H{"code": 0, "message": "success", "data": result})
}
